//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    detailGET(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET(_response);
        });
    }

    protected processDetailGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dynamic(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/detail/dynamic?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDynamic(_response);
        });
    }

    protected processDynamic(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listPOST(body?: AlbumListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPOST(_response);
        });
    }

    protected processListPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    style(body?: AlbumListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/list/style";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStyle(_response);
        });
    }

    protected processStyle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    new(body?: AlbumNewRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNew(_response);
        });
    }

    protected processNew(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    newest( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/newest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewest(_response);
        });
    }

    protected processNewest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    privilege(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/privilege?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivilege(_response);
        });
    }

    protected processPrivilege(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sales(body?: AlbumSongsaleboardRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/sales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSales(_response);
        });
    }

    protected processSales(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param t (optional) 
     * @param id (optional) 
     * @return Success
     */
    subscribe(t?: number | undefined, id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/subscribe?";
        if (t === null)
            throw new Error("The parameter 't' cannot be null.");
        else if (t !== undefined)
            url_ += "t=" + encodeURIComponent("" + t) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribe(_response);
        });
    }

    protected processSubscribe(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribed(body?: AlbumSublistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/subscribed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribed(_response);
        });
    }

    protected processSubscribed(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    artistAlbums(body?: ArtistAlbumRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Album/ArtistAlbums";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistAlbums(_response);
        });
    }

    protected processArtistAlbums(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    detailsGET(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/details?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailsGET(_response);
        });
    }

    protected processDetailsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    description(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/description?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDescription(_response);
        });
    }

    protected processDescription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    count(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/fans/count?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mvs(body?: ArtistMvRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/mvs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvs(_response);
        });
    }

    protected processMvs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    filtered(body?: ArtistListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/filtered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFiltered(_response);
        });
    }

    protected processFiltered(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    dynamic2(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/dynamic?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDynamic2(_response);
        });
    }

    protected processDynamic2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    songsGET(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/top/songs?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongsGET(_response);
        });
    }

    protected processSongsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    videos(body?: ArtistVideoRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/videos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVideos(_response);
        });
    }

    protected processVideos(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    new2(body?: ArtistNewSongRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/songs/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNew2(_response);
        });
    }

    protected processNew2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    new3(body?: ArtistNewMvRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/mvs/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNew3(_response);
        });
    }

    protected processNew3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songsPOST(body?: ArtistSongsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Artist/songs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongsPOST(_response);
        });
    }

    protected processSongsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    match(body?: AudioMatchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Audio/match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatch(_response);
        });
    }

    protected processMatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param clientType (optional) 
     * @return Success
     */
    s(clientType?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Banner/s?";
        if (clientType === null)
            throw new Error("The parameter 'clientType' cannot be null.");
        else if (clientType !== undefined)
            url_ += "clientType=" + encodeURIComponent("" + clientType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processS(_response);
        });
    }

    protected processS(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batch(body?: BatchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatch(_response);
        });
    }

    protected processBatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailsPOST(body?: CalendarRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Calendar/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailsPOST(_response);
        });
    }

    protected processDetailsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param phone (optional) 
     * @param ctcode (optional) 
     * @return Success
     */
    sent(phone?: number | undefined, ctcode?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Captcha/sent?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (ctcode === null)
            throw new Error("The parameter 'ctcode' cannot be null.");
        else if (ctcode !== undefined)
            url_ += "Ctcode=" + encodeURIComponent("" + ctcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSent(_response);
        });
    }

    protected processSent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verify(body?: CaptchaVerifyRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Captcha/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    music(body?: CheckMusicRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Check/music";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMusic(_response);
        });
    }

    protected processMusic(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadsong(body?: SongUploadRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Cloud/uploadsong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadsong(_response);
        });
    }

    protected processUploadsong(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importsongs(body?: SongImportRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Cloud/importsongs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportsongs(_response);
        });
    }

    protected processImportsongs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    matchsong(body?: SongMatchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Cloud/matchsong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatchsong(_response);
        });
    }

    protected processMatchsong(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body?: CloudSearchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Cloud/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manage(body?: CommentManageRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManage(_response);
        });
    }

    protected processManage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    albums(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/albums";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbums(_response);
        });
    }

    protected processAlbums(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    djs(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/djs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDjs(_response);
        });
    }

    protected processDjs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    events(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvents(_response);
        });
    }

    protected processEvents(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    floors(body?: CommentFloorRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/floors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFloors(_response);
        });
    }

    protected processFloors(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hots(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/hots";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHots(_response);
        });
    }

    protected processHots(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    huglist(body?: CommentHugListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/huglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHuglist(_response);
        });
    }

    protected processHuglist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    like(body?: CommentLikeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/like";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLike(_response);
        });
    }

    protected processLike(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    musics(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/musics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMusics(_response);
        });
    }

    protected processMusics(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mvs2(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/mvs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvs2(_response);
        });
    }

    protected processMvs2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    news(body?: CommentNewRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNews(_response);
        });
    }

    protected processNews(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlists(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/playlists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylists(_response);
        });
    }

    protected processPlaylists(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    videos2(body?: CommentRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Comment/videos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVideos2(_response);
        });
    }

    protected processVideos2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    codelist( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Countries/codelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCodelist(_response);
        });
    }

    protected processCodelist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param albumId (optional) 
     * @return Success
     */
    albumdetail(albumId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/DigitalAlbum/albumdetail?";
        if (albumId === null)
            throw new Error("The parameter 'albumId' cannot be null.");
        else if (albumId !== undefined)
            url_ += "albumId=" + encodeURIComponent("" + albumId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumdetail(_response);
        });
    }

    protected processAlbumdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderalbum(body?: DigitalAlbumOrderRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/DigitalAlbum/orderalbum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderalbum(_response);
        });
    }

    protected processOrderalbum(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchasedalbums(body?: PurchasedAlbumsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/DigitalAlbum/purchasedalbums";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPurchasedalbums(_response);
        });
    }

    protected processPurchasedalbums(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    albumsales(body?: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/DigitalAlbum/albumsales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumsales(_response);
        });
    }

    protected processAlbumsales(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    agedistribution( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/FansCenter/agedistribution";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAgedistribution(_response);
        });
    }

    protected processAgedistribution(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    genderdistribution( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/FansCenter/genderdistribution";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenderdistribution(_response);
        });
    }

    protected processGenderdistribution(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    provincedistribution( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/FansCenter/provincedistribution";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProvincedistribution(_response);
        });
    }

    protected processProvincedistribution(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    overview( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/FansCenter/overview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOverview(_response);
        });
    }

    protected processOverview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trendlist(body?: FansCenterTrendRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/FansCenter/trendlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTrendlist(_response);
        });
    }

    protected processTrendlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recommendedsongsGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/History/recommendedsongs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendedsongsGET(_response);
        });
    }

    protected processRecommendedsongsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recommendedsongsdetail(body?: HistoryRecommendSongsDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/History/recommendedsongsdetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendedsongsdetail(_response);
        });
    }

    protected processRecommendedsongsdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockpage(body?: HomepageBlockPageRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Homepage/blockpage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlockpage(_response);
        });
    }

    protected processBlockpage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    dragonball( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Homepage/dragonball";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDragonball(_response);
        });
    }

    protected processDragonball(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    realtimereport(body?: ListenDataRealtimeReportRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Listen/realtimereport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRealtimereport(_response);
        });
    }

    protected processRealtimereport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    report(body?: ListenDataReportRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Listen/report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReport(_response);
        });
    }

    protected processReport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    todaysongs( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Listen/todaysongs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTodaysongs(_response);
        });
    }

    protected processTodaysongs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    total( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Listen/total";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTotal(_response);
        });
    }

    protected processTotal(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    yearreport( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Listen/yearreport";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processYearreport(_response);
        });
    }

    protected processYearreport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptinvitation(body?: ListenTogetherAcceptRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/acceptinvitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAcceptinvitation(_response);
        });
    }

    protected processAcceptinvitation(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param roomId (optional) 
     * @return Success
     */
    endsession(roomId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/endsession?";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEndsession(_response);
        });
    }

    protected processEndsession(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendheartbeat(body?: ListenTogetherHeartbeatRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/sendheartbeat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendheartbeat(_response);
        });
    }

    protected processSendheartbeat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendplaycommand(body?: ListenTogetherPlayCommandRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/sendplaycommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendplaycommand(_response);
        });
    }

    protected processSendplaycommand(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param roomId (optional) 
     * @return Success
     */
    checkroomstatus(roomId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/checkroomstatus?";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckroomstatus(_response);
        });
    }

    protected processCheckroomstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    createroom( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/createroom";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateroom(_response);
        });
    }

    protected processCreateroom(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    sessionstatus( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/sessionstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSessionstatus(_response);
        });
    }

    protected processSessionstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    synccommandlist(body?: ListenTogetherSyncCommandRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/synccommandlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSynccommandlist(_response);
        });
    }

    protected processSynccommandlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param roomId (optional) 
     * @return Success
     */
    syncplaylist(roomId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/ListenTogether/syncplaylist?";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncplaylist(_response);
        });
    }

    protected processSyncplaylist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cellphone(body?: LoginCellphoneRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/cellphone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCellphone(_response);
        });
    }

    protected processCellphone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    qrcheck(key?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/qrcheck?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQrcheck(_response);
        });
    }

    protected processQrcheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param key (optional) 
     * @param qrimg (optional) 
     * @return Success
     */
    generateqrurl(key?: string | undefined, qrimg?: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/generateqrurl?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (qrimg === null)
            throw new Error("The parameter 'qrimg' cannot be null.");
        else if (qrimg !== undefined)
            url_ += "qrimg=" + encodeURIComponent("" + qrimg) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateqrurl(_response);
        });
    }

    protected processGenerateqrurl(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    qrkey( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/qrkey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQrkey(_response);
        });
    }

    protected processQrkey(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    refresh( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    status( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    logout( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Login/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param songId (optional) 
     * @return Success
     */
    s2(songId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lyric/s?";
        if (songId === null)
            throw new Error("The parameter 'songId' cannot be null.");
        else if (songId !== undefined)
            url_ += "songId=" + encodeURIComponent("" + songId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processS2(_response);
        });
    }

    protected processS2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param songId (optional) 
     * @return Success
     */
    advanceds(songId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Lyric/advanceds?";
        if (songId === null)
            throw new Error("The parameter 'songId' cannot be null.");
        else if (songId !== undefined)
            url_ += "songId=" + encodeURIComponent("" + songId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdvanceds(_response);
        });
    }

    protected processAdvanceds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    musicrcmd(body?: MlogMusicRcmdRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mlog/musicrcmd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMusicrcmd(_response);
        });
    }

    protected processMusicrcmd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tovideo(body?: MlogToVideoRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mlog/tovideo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTovideo(_response);
        });
    }

    protected processTovideo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlPOST(body?: MlogUrlRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mlog/url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlPOST(_response);
        });
    }

    protected processUrlPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    comments(body?: MsgCommentsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processComments(_response);
        });
    }

    protected processComments(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forwards(body?: MsgForwardsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/forwards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processForwards(_response);
        });
    }

    protected processForwards(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notices(body?: MsgNoticesRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/notices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNotices(_response);
        });
    }

    protected processNotices(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privatemessages(body?: MsgPrivateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/privatemessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivatemessages(_response);
        });
    }

    protected processPrivatemessages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privatehistory(body?: MsgPrivateHistoryRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/privatehistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivatehistory(_response);
        });
    }

    protected processPrivatehistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recentcontacts( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Msg/recentcontacts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentcontacts(_response);
        });
    }

    protected processRecentcontacts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param songId (optional) 
     * @return Success
     */
    startlistening(songId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Music/startlistening?";
        if (songId === null)
            throw new Error("The parameter 'songId' cannot be null.");
        else if (songId !== undefined)
            url_ += "SongId=" + encodeURIComponent("" + songId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStartlistening(_response);
        });
    }

    protected processStartlistening(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    cloudbeanbalance( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/cloudbeanbalance";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCloudbeanbalance(_response);
        });
    }

    protected processCloudbeanbalance(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claimcloudbeans(body?: MusicianCloudbeanClaimRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/claimcloudbeans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimcloudbeans(_response);
        });
    }

    protected processClaimcloudbeans(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    dataoverview( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/dataoverview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDataoverview(_response);
        });
    }

    protected processDataoverview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playtrend(body?: MusicianPlayTrendRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/playtrend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaytrend(_response);
        });
    }

    protected processPlaytrend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    signinGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/signin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSigninGET(_response);
        });
    }

    protected processSigninGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tasks( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/tasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTasks(_response);
        });
    }

    protected processTasks(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    newtasks( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Musician/newtasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewtasks(_response);
        });
    }

    protected processNewtasks(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body?: MvAllRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param mvid (optional) 
     * @return Success
     */
    detailGET2(mvid?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/detail?";
        if (mvid === null)
            throw new Error("The parameter 'mvid' cannot be null.");
        else if (mvid !== undefined)
            url_ += "mvid=" + encodeURIComponent("" + mvid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET2(_response);
        });
    }

    protected processDetailGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param mvid (optional) 
     * @return Success
     */
    detailinfo(mvid?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/detailinfo?";
        if (mvid === null)
            throw new Error("The parameter 'mvid' cannot be null.");
        else if (mvid !== undefined)
            url_ += "mvid=" + encodeURIComponent("" + mvid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailinfo(_response);
        });
    }

    protected processDetailinfo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    exclusivercmd(limit?: number | undefined, offset?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/exclusivercmd?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExclusivercmd(_response);
        });
    }

    protected processExclusivercmd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    first(body?: MvFirstRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/first";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFirst(_response);
        });
    }

    protected processFirst(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribe2(body?: MvSubscribeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribe2(_response);
        });
    }

    protected processSubscribe2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    sublistGET(limit?: number | undefined, offset?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/sublist?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSublistGET(_response);
        });
    }

    protected processSublistGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlPOST2(body?: MvUrlRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Mv/url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlPOST2(_response);
        });
    }

    protected processUrlPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recommendationsPOST(body?: PersonalizedRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/recommendations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendationsPOST(_response);
        });
    }

    protected processRecommendationsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    djprogram( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/djprogram";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDjprogram(_response);
        });
    }

    protected processDjprogram(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    mvGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/mv";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvGET(_response);
        });
    }

    protected processMvGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    newsong(body?: PersonalizedNewsongRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/newsong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewsong(_response);
        });
    }

    protected processNewsong(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    privatecontent( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/privatecontent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivatecontent(_response);
        });
    }

    protected processPrivatecontent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privatecontentlist(body?: PersonalizedPrivatecontentListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/privatecontentlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivatecontentlist(_response);
        });
    }

    protected processPrivatecontentlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    personalfm( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/personalfm";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonalfm(_response);
        });
    }

    protected processPersonalfm(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personalfmmode(body?: PersonalFmModeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Personalized/personalfmmode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonalfmmode(_response);
        });
    }

    protected processPersonalfmmode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    count2( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Pl/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCount2(_response);
        });
    }

    protected processCount2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    catlist( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/catlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatlist(_response);
        });
    }

    protected processCatlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    coverupdate(body?: PlaylistCoverUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/coverupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCoverupdate(_response);
        });
    }

    protected processCoverupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: PlaylistCreateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    descupdate(body?: PlaylistDescUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/descupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDescupdate(_response);
        });
    }

    protected processDescupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tdetail(body?: PlaylistDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/tdetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTdetail(_response);
        });
    }

    protected processTdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param subscriberLimit (optional) 
     * @return Success
     */
    detaildynamic(id?: number | undefined, subscriberLimit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/detaildynamic?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (subscriberLimit === null)
            throw new Error("The parameter 'subscriberLimit' cannot be null.");
        else if (subscriberLimit !== undefined)
            url_ += "subscriberLimit=" + encodeURIComponent("" + subscriberLimit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetaildynamic(_response);
        });
    }

    protected processDetaildynamic(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailrcmd(body?: PlaylistDetailRcmdRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/detailrcmd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailrcmd(_response);
        });
    }

    protected processDetailrcmd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    highqualitytags( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/highqualitytags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHighqualitytags(_response);
        });
    }

    protected processHighqualitytags(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    hotGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/hot";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotGET(_response);
        });
    }

    protected processHotGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importnametaskcreate(body?: PlaylistImportNameTaskRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/importnametaskcreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportnametaskcreate(_response);
        });
    }

    protected processImportnametaskcreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    importtaskstatus(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/importtaskstatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImporttaskstatus(_response);
        });
    }

    protected processImporttaskstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mylike(body?: PlaylistMyLikeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/mylike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMylike(_response);
        });
    }

    protected processMylike(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    nameupdate(body?: PlaylistNameUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/nameupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNameupdate(_response);
        });
    }

    protected processNameupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderupdate(body?: PlaylistOrderUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/orderupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderupdate(_response);
        });
    }

    protected processOrderupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    privacy(body?: PlaylistPrivacyRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/privacy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrivacy(_response);
        });
    }

    protected processPrivacy(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribe3(body?: PlaylistSubscribeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribe3(_response);
        });
    }

    protected processSubscribe3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribers(body?: PlaylistSubscribersRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/subscribers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribers(_response);
        });
    }

    protected processSubscribers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagsupdate(body?: PlaylistTagsUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/tagsupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsupdate(_response);
        });
    }

    protected processTagsupdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tracksmanipulate(body?: PlaylistTracksManipulateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/tracksmanipulate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTracksmanipulate(_response);
        });
    }

    protected processTracksmanipulate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trackadd(body?: PlaylistTrackAddRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/trackadd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTrackadd(_response);
        });
    }

    protected processTrackadd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trackall(body?: PlaylistTrackAllRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/trackall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTrackall(_response);
        });
    }

    protected processTrackall(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trackdelete(body?: PlaylistTrackAddRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/trackdelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTrackdelete(_response);
        });
    }

    protected processTrackdelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body?: PlaylistUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    updateplaycount(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/updateplaycount?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateplaycount(_response);
        });
    }

    protected processUpdateplaycount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    videorecent( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playlist/videorecent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVideorecent(_response);
        });
    }

    protected processVideorecent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    intelligencelist(body?: PlaymodeIntelligenceListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playmode/intelligencelist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIntelligencelist(_response);
        });
    }

    protected processIntelligencelist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songvector(body?: PlaymodeSongVectorRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Playmode/songvector";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongvector(_response);
        });
    }

    protected processSongvector(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recommendPOST(body?: ProgramRecommendRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Program/recommend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendPOST(_response);
        });
    }

    protected processRecommendPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    banner( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/banner";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBanner(_response);
        });
    }

    protected processBanner(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    categoryexcludehot( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/categoryexcludehot";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategoryexcludehot(_response);
        });
    }

    protected processCategoryexcludehot(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    categoryrecommend( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/categoryrecommend";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategoryrecommend(_response);
        });
    }

    protected processCategoryrecommend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    categorylistGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/categorylist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategorylistGET(_response);
        });
    }

    protected processCategorylistGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param rid (optional) 
     * @return Success
     */
    detailGET3(rid?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/detail?";
        if (rid === null)
            throw new Error("The parameter 'rid' cannot be null.");
        else if (rid !== undefined)
            url_ += "rid=" + encodeURIComponent("" + rid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET3(_response);
        });
    }

    protected processDetailGET3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hotPOST(body?: RadioHotRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/hot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotPOST(_response);
        });
    }

    protected processHotPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paygift(body?: RadioPayGiftRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/paygift";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaygift(_response);
        });
    }

    protected processPaygift(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    personalizedrecommend(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/personalizedrecommend?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonalizedrecommend(_response);
        });
    }

    protected processPersonalizedrecommend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    programs(body?: RadioProgramsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/programs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrograms(_response);
        });
    }

    protected processPrograms(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    programdetail(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/programdetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProgramdetail(_response);
        });
    }

    protected processProgramdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    programtoplist(body?: RadioProgramToplistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/programtoplist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProgramtoplist(_response);
        });
    }

    protected processProgramtoplist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    programtoplistbyhour(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/programtoplistbyhour?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProgramtoplistbyhour(_response);
        });
    }

    protected processProgramtoplistbyhour(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hotstations(body?: RadioHotStationsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/hotstations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotstations(_response);
        });
    }

    protected processHotstations(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recommendGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/recommend";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendGET(_response);
        });
    }

    protected processRecommendGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param cateId (optional) 
     * @return Success
     */
    recommendbytype(cateId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/recommendbytype?";
        if (cateId === null)
            throw new Error("The parameter 'cateId' cannot be null.");
        else if (cateId !== undefined)
            url_ += "cateId=" + encodeURIComponent("" + cateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendbytype(_response);
        });
    }

    protected processRecommendbytype(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscription(body?: RadioSubscriptionRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/subscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscription(_response);
        });
    }

    protected processSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscriptions(body?: RadioSubscriptionsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscriptions(_response);
        });
    }

    protected processSubscriptions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribers2(body?: RadioSubscribersRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/subscribers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribers2(_response);
        });
    }

    protected processSubscribers2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @return Success
     */
    todaypreferred(page?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/todaypreferred?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTodaypreferred(_response);
        });
    }

    protected processTodaypreferred(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toplist(body?: RadioToplistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/toplist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToplist(_response);
        });
    }

    protected processToplist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    trashsong(body?: RadioTrashSongRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/trashsong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTrashsong(_response);
        });
    }

    protected processTrashsong(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    like2(body?: RadioLikeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/like";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLike2(_response);
        });
    }

    protected processLike2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rankings(body?: RadioRankingRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Radio/rankings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRankings(_response);
        });
    }

    protected processRankings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    resourceGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Recommend/resource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResourceGET(_response);
        });
    }

    protected processResourceGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    songsGET2( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Recommend/songs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongsGET2(_response);
        });
    }

    protected processSongsGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songsdislike(body?: RecommendSongsDislikeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Recommend/songsdislike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongsdislike(_response);
        });
    }

    protected processSongsdislike(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentalbum(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentalbum?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentalbum(_response);
        });
    }

    protected processRecentalbum(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentradio(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentradio?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentradio(_response);
        });
    }

    protected processRecentradio(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentplaylist(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentplaylist?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentplaylist(_response);
        });
    }

    protected processRecentplaylist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentsong(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentsong?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentsong(_response);
        });
    }

    protected processRecentsong(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentvideo(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentvideo?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentvideo(_response);
        });
    }

    protected processRecentvideo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    recentvoice(limit?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentvoice?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentvoice(_response);
        });
    }

    protected processRecentvoice(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recentlistenlist( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Record/recentlistenlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecentlistenlist(_response);
        });
    }

    protected processRecentlistenlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    anonymous( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Register/anonymous";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAnonymous(_response);
        });
    }

    protected processAnonymous(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cellphone2(body?: RegisterCellphoneRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Register/cellphone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCellphone2(_response);
        });
    }

    protected processCellphone2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    allvideo(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Related/allvideo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllvideo(_response);
        });
    }

    protected processAllvideo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    playlistGET(id?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Related/playlist?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistGET(_response);
        });
    }

    protected processPlaylistGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body?: SearchInputModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    default( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefault(_response);
        });
    }

    protected processDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    hotGET2(type?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/hot?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotGET2(_response);
        });
    }

    protected processHotGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    hotdetail( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/hotdetail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotdetail(_response);
        });
    }

    protected processHotdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    match2(body?: SearchMatchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatch2(_response);
        });
    }

    protected processMatch2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @param keywords (optional) 
     * @return Success
     */
    multimatch(type?: number | undefined, keywords?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/multimatch?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (keywords === null)
            throw new Error("The parameter 'keywords' cannot be null.");
        else if (keywords !== undefined)
            url_ += "keywords=" + encodeURIComponent("" + keywords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMultimatch(_response);
        });
    }

    protected processMultimatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param keywords (optional) 
     * @param type (optional) 
     * @return Success
     */
    suggest(keywords?: string | undefined, type?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Search/suggest?";
        if (keywords === null)
            throw new Error("The parameter 'keywords' cannot be null.");
        else if (keywords !== undefined)
            url_ += "keywords=" + encodeURIComponent("" + keywords) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSuggest(_response);
        });
    }

    protected processSuggest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    albumPOST(body?: SendAlbumRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Send/album";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumPOST(_response);
        });
    }

    protected processAlbumPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlistPOST(body?: SendPlaylistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Send/playlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistPOST(_response);
        });
    }

    protected processPlaylistPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songPOST(body?: SendSongRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Send/song";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongPOST(_response);
        });
    }

    protected processSongPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    text(body?: SendTextRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Send/text";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processText(_response);
        });
    }

    protected processText(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resourcePOST(body?: ShareResourceRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Share/resource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResourcePOST(_response);
        });
    }

    protected processResourcePOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listPOST2(body?: SheetListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Sheet/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPOST2(_response);
        });
    }

    protected processListPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preview(body?: SheetPreviewRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Sheet/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    progress(body?: SigninProgressRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Signin/progress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProgress(_response);
        });
    }

    protected processProgress(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    signhappyinfo( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Signin/signhappyinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignhappyinfo(_response);
        });
    }

    protected processSignhappyinfo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    artistGET(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Simi/artist?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistGET(_response);
        });
    }

    protected processArtistGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param mvId (optional) 
     * @return Success
     */
    mvGET2(mvId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Simi/mv?";
        if (mvId === null)
            throw new Error("The parameter 'mvId' cannot be null.");
        else if (mvId !== undefined)
            url_ += "mvId=" + encodeURIComponent("" + mvId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvGET2(_response);
        });
    }

    protected processMvGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlistPOST2(body?: SimiPlaylistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Simi/playlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistPOST2(_response);
        });
    }

    protected processPlaylistPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songPOST2(body?: SimiSongRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Simi/song";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongPOST2(_response);
        });
    }

    protected processSongPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    user(body?: SimiUserRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Simi/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    chorus(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/chorus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChorus(_response);
        });
    }

    protected processChorus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailPOST(body?: SongDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailPOST(_response);
        });
    }

    protected processDetailPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    downlist(body?: PaginatedRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/downlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownlist(_response);
        });
    }

    protected processDownlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param bitrate (optional) 
     * @return Success
     */
    downloadurl(id?: number | undefined, bitrate?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/downloadurl?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (bitrate === null)
            throw new Error("The parameter 'bitrate' cannot be null.");
        else if (bitrate !== undefined)
            url_ += "bitrate=" + encodeURIComponent("" + bitrate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadurl(_response);
        });
    }

    protected processDownloadurl(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param level (optional) 
     * @return Success
     */
    downloadurlv1(id?: number | undefined, level?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/downloadurlv1?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "level=" + encodeURIComponent("" + level) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadurlv1(_response);
        });
    }

    protected processDownloadurlv1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dynamiccover(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/dynamiccover?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDynamiccover(_response);
        });
    }

    protected processDynamiccover(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    likecheck(body?: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/likecheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLikecheck(_response);
        });
    }

    protected processLikecheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    monthdownlist(body?: PaginatedRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/monthdownlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMonthdownlist(_response);
        });
    }

    protected processMonthdownlist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    musicdetail(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/musicdetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMusicdetail(_response);
        });
    }

    protected processMusicdetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderupdate2(body?: SongOrderUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/orderupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderupdate2(_response);
        });
    }

    protected processOrderupdate2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlPOST3(body?: SongUrlRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlPOST3(_response);
        });
    }

    protected processUrlPOST3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlv1(body?: SongUrlV1RequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/urlv1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlv1(_response);
        });
    }

    protected processUrlv1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    wikisummary(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Song/wikisummary?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWikisummary(_response);
        });
    }

    protected processWikisummary(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    albumPOST2(body?: StyleRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/album";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumPOST2(_response);
        });
    }

    protected processAlbumPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    artistPOST(body?: StyleRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/artist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistPOST(_response);
        });
    }

    protected processArtistPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param tagId (optional) 
     * @return Success
     */
    detailGET4(tagId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/detail?";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "tagId=" + encodeURIComponent("" + tagId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET4(_response);
        });
    }

    protected processDetailGET4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    listGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListGET(_response);
        });
    }

    protected processListGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlistPOST3(body?: StyleRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/playlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistPOST3(_response);
        });
    }

    protected processPlaylistPOST3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    preference( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/preference";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreference(_response);
        });
    }

    protected processPreference(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    songPOST3(body?: StyleRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Style/song";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongPOST3(_response);
        });
    }

    protected processSongPOST3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    annual(body?: SummaryAnnualRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Summary/annual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAnnual(_response);
        });
    }

    protected processAnnual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    detailGET5( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Threshold/detail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET5(_response);
        });
    }

    protected processDetailGET5(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    albumPOST3(body?: TopAlbumRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/album";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumPOST3(_response);
        });
    }

    protected processAlbumPOST3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    artists(limit?: number | undefined, offset?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/artists?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtists(_response);
        });
    }

    protected processArtists(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    listGET2(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/list?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListGET2(_response);
        });
    }

    protected processListGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mvPOST(body?: TopMvRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/mv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvPOST(_response);
        });
    }

    protected processMvPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlistPOST4(body?: TopPlaylistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/playlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistPOST4(_response);
        });
    }

    protected processPlaylistPOST4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    playlisthighquality(body?: TopPlaylistHighqualityRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/playlisthighquality";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylisthighquality(_response);
        });
    }

    protected processPlaylisthighquality(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param areaId (optional) 
     * @return Success
     */
    songGET(areaId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/song?";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongGET(_response);
        });
    }

    protected processSongGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    artistrankings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/artistrankings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistrankings(_response);
        });
    }

    protected processArtistrankings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    detailGET6( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Top/detail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET6(_response);
        });
    }

    protected processDetailGET6(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailPOST2(body?: TopicDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Topic/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailPOST2(_response);
        });
    }

    protected processDetailPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detaileventhot(body?: TopicDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Topic/detaileventhot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetaileventhot(_response);
        });
    }

    protected processDetaileventhot(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sublistPOST(body?: TopicSublistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Topic/sublist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSublistPOST(_response);
        });
    }

    protected processSublistPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    hotGET3( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Topic/hot";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHotGET3(_response);
        });
    }

    protected processHotGET3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    toplist( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Toplist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToplist(_response);
        });
    }

    protected processToplist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    artistPOST2(body?: ToplistArtistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Toplist/artist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistPOST2(_response);
        });
    }

    protected processArtistPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    detailGET7( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Toplist/detail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET7(_response);
        });
    }

    protected processDetailGET7(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param albumId (optional) 
     * @return Success
     */
    albumGET(albumId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/album?";
        if (albumId === null)
            throw new Error("The parameter 'albumId' cannot be null.");
        else if (albumId !== undefined)
            url_ += "albumId=" + encodeURIComponent("" + albumId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlbumGET(_response);
        });
    }

    protected processAlbumGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @return Success
     */
    artistGET2(artistId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/artist?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistGET2(_response);
        });
    }

    protected processArtistGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    artistsearch(body?: UgcArtistSearchRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/artistsearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArtistsearch(_response);
        });
    }

    protected processArtistsearch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailPOST3(body?: UgcDetailRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailPOST3(_response);
        });
    }

    protected processDetailPOST3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param mvId (optional) 
     * @return Success
     */
    mvGET3(mvId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/mv?";
        if (mvId === null)
            throw new Error("The parameter 'mvId' cannot be null.");
        else if (mvId !== undefined)
            url_ += "mvId=" + encodeURIComponent("" + mvId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMvGET3(_response);
        });
    }

    protected processMvGET3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param songId (optional) 
     * @return Success
     */
    songGET2(songId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/song?";
        if (songId === null)
            throw new Error("The parameter 'songId' cannot be null.");
        else if (songId !== undefined)
            url_ += "songId=" + encodeURIComponent("" + songId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongGET2(_response);
        });
    }

    protected processSongGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    userdevote( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Ugc/userdevote";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserdevote(_response);
        });
    }

    protected processUserdevote(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    account( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccount(_response);
        });
    }

    protected processAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    detailGET8(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/detail?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET8(_response);
        });
    }

    protected processDetailGET8(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update2(body?: UserUpdateRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate2(_response);
        });
    }

    protected processUpdate2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPOST(body?: CellphoneExistenceCheckRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/cellphone/check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPOST(_response);
        });
    }

    protected processCheckPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    playlistGET2(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/playlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlaylistGET2(_response);
        });
    }

    protected processPlaylistGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    upload(body?: AvatarUploadRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/avatar/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    status2(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/social/status?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus2(_response);
        });
    }

    protected processStatus2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    edit(body?: UserSocialStatusEditRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/social/status/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    level( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/level";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLevel(_response);
        });
    }

    protected processLevel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    event(body?: UserEventRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvent(_response);
        });
    }

    protected processEvent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param follow (optional) 
     * @return Success
     */
    follow(userId?: number | undefined, follow?: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/follow?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (follow === null)
            throw new Error("The parameter 'follow' cannot be null.");
        else if (follow !== undefined)
            url_ += "follow=" + encodeURIComponent("" + follow) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFollow(_response);
        });
    }

    protected processFollow(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    followers(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/followers?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFollowers(_response);
        });
    }

    protected processFollowers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    audio(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/audio?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAudio(_response);
        });
    }

    protected processAudio(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    binding(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/binding?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBinding(_response);
        });
    }

    protected processBinding(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cellphone3(body?: BindingCellphoneRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/binding/cellphone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCellphone3(_response);
        });
    }

    protected processCellphone3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    cloud(limit?: number | undefined, offset?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/cloud?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCloud(_response);
        });
    }

    protected processCloud(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param songId (optional) 
     * @return Success
     */
    songDELETE(songId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/cloud/song?";
        if (songId === null)
            throw new Error("The parameter 'songId' cannot be null.");
        else if (songId !== undefined)
            url_ += "songId=" + encodeURIComponent("" + songId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSongDELETE(_response);
        });
    }

    protected processSongDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    detailPOST4(body?: number[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/cloud/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailPOST4(_response);
        });
    }

    protected processDetailPOST4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    history(body?: UserCommentHistoryRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/comment/history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    medal(userId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/medal?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMedal(_response);
        });
    }

    protected processMedal(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param friendId (optional) 
     * @return Success
     */
    mutualfollow(friendId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/mutualfollow?";
        if (friendId === null)
            throw new Error("The parameter 'friendId' cannot be null.");
        else if (friendId !== undefined)
            url_ += "friendId=" + encodeURIComponent("" + friendId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMutualfollow(_response);
        });
    }

    protected processMutualfollow(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mixed(body?: UserFollowMixedRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/follow/mixed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMixed(_response);
        });
    }

    protected processMixed(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    followeds(body?: UserFollowedsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/followeds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFolloweds(_response);
        });
    }

    protected processFolloweds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param type (optional) 
     * @return Success
     */
    record(userId?: number | undefined, type?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/record?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecord(_response);
        });
    }

    protected processRecord(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    phone(body?: UserReplacePhoneRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/rebind/phone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPhone(_response);
        });
    }

    protected processPhone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recommendationsGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/social/status/recommendations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendationsGET(_response);
        });
    }

    protected processRecommendationsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    support( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/social/status/support";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSupport(_response);
        });
    }

    protected processSupport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    subcount( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/subcount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubcount(_response);
        });
    }

    protected processSubcount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    profile(body?: ActivateInitProfileRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/activate/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    signinPOST(type?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/daily/signin?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSigninPOST(_response);
        });
    }

    protected processSigninPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ids(body?: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/user/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIds(_response);
        });
    }

    protected processIds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param nickname (optional) 
     * @return Success
     */
    checkGET(nickname?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/nickname/check?";
        if (nickname === null)
            throw new Error("The parameter 'nickname' cannot be null.");
        else if (nickname !== undefined)
            url_ += "nickname=" + encodeURIComponent("" + nickname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckGET(_response);
        });
    }

    protected processCheckGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    settings( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettings(_response);
        });
    }

    protected processSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    like3(body?: ResourceLikeRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/resource/like";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLike3(_response);
        });
    }

    protected processLike3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    authInfo( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/creator/auth-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthInfo(_response);
        });
    }

    protected processAuthInfo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param artistId (optional) 
     * @param subscribe (optional) 
     * @return Success
     */
    manageSubscription(artistId?: number | undefined, subscribe?: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/artist/manage-subscription?";
        if (artistId === null)
            throw new Error("The parameter 'artistId' cannot be null.");
        else if (artistId !== undefined)
            url_ += "artistId=" + encodeURIComponent("" + artistId) + "&";
        if (subscribe === null)
            throw new Error("The parameter 'subscribe' cannot be null.");
        else if (subscribe !== undefined)
            url_ += "subscribe=" + encodeURIComponent("" + subscribe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processManageSubscription(_response);
        });
    }

    protected processManageSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribed2(body?: ArtistSublistRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/User/artist/subscribed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribed2(_response);
        });
    }

    protected processSubscribed2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param qrCode (optional) 
     * @return Success
     */
    checkqrcodestatus(qrCode?: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Verify/checkqrcodestatus?";
        if (qrCode === null)
            throw new Error("The parameter 'qrCode' cannot be null.");
        else if (qrCode !== undefined)
            url_ += "qrCode=" + encodeURIComponent("" + qrCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckqrcodestatus(_response);
        });
    }

    protected processCheckqrcodestatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categorylistPOST(body?: VideoCategoryListRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/categorylist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategorylistPOST(_response);
        });
    }

    protected processCategorylistPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    detailGET9(id?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailGET9(_response);
        });
    }

    protected processDetailGET9(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param vid (optional) 
     * @return Success
     */
    detailinfo2(vid?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/detailinfo?";
        if (vid === null)
            throw new Error("The parameter 'vid' cannot be null.");
        else if (vid !== undefined)
            url_ += "vid=" + encodeURIComponent("" + vid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetailinfo2(_response);
        });
    }

    protected processDetailinfo2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    group(body?: VideoGroupRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGroup(_response);
        });
    }

    protected processGroup(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    grouplist( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/grouplist";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGrouplist(_response);
        });
    }

    protected processGrouplist(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param subscribe (optional) 
     * @return Success
     */
    sub(id?: number | undefined, subscribe?: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/sub?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (subscribe === null)
            throw new Error("The parameter 'subscribe' cannot be null.");
        else if (subscribe !== undefined)
            url_ += "subscribe=" + encodeURIComponent("" + subscribe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSub(_response);
        });
    }

    protected processSub(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timelineall(body?: VideoTimelineRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/timelineall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTimelineall(_response);
        });
    }

    protected processTimelineall(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timelinerecommend(body?: VideoTimelineRecommendRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/timelinerecommend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTimelinerecommend(_response);
        });
    }

    protected processTimelinerecommend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param resolution (optional) 
     * @return Success
     */
    urlGET(id?: number | undefined, resolution?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Video/url?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (resolution === null)
            throw new Error("The parameter 'resolution' cannot be null.");
        else if (resolution !== undefined)
            url_ += "resolution=" + encodeURIComponent("" + resolution) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlGET(_response);
        });
    }

    protected processUrlGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    growthpointGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/growthpoint";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGrowthpointGET(_response);
        });
    }

    protected processGrowthpointGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    growthpointPOST(body?: VipGrowthpointGetRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/growthpoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGrowthpointPOST(_response);
        });
    }

    protected processGrowthpointPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    growthpointdetails(body?: VipGrowthPointDetailsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/growthpointdetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGrowthpointdetails(_response);
        });
    }

    protected processGrowthpointdetails(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    infoPOST(body?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInfoPOST(_response);
        });
    }

    protected processInfoPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    infov2(body?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/infov2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInfov2(_response);
        });
    }

    protected processInfov2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tasks2( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/tasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTasks2(_response);
        });
    }

    protected processTasks2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timemachine(body?: VipTimeMachineRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Vip/timemachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTimemachine(_response);
        });
    }

    protected processTimemachine(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    weblog(body?: any | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Weblog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWeblog(_response);
        });
    }

    protected processWeblog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    points( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/points";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoints(_response);
        });
    }

    protected processPoints(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    expensehistory(body?: YunbeiExpenseRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/expensehistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExpensehistory(_response);
        });
    }

    protected processExpensehistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    infoGET( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recommendedsongsPOST(body?: YunbeiRecommendedSongsRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/recommendedsongs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendedsongsPOST(_response);
        });
    }

    protected processRecommendedsongsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recommendedsonghistory(body?: YunbeiRcmdSongHistoryRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/recommendedsonghistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecommendedsonghistory(_response);
        });
    }

    protected processRecommendedsonghistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    receipt(body?: YunbeiReceiptRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/receipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceipt(_response);
        });
    }

    protected processReceipt(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    dailysignin( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/dailysignin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDailysignin(_response);
        });
    }

    protected processDailysignin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tasks3( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/tasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTasks3(_response);
        });
    }

    protected processTasks3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    todotasks( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/todotasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTodotasks(_response);
        });
    }

    protected processTodotasks(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completetask(body?: YunbeiTaskFinishRequestModel | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/completetask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompletetask(_response);
        });
    }

    protected processCompletetask(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    today( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Yunbei/today";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToday(_response);
        });
    }

    protected processToday(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ActivateInitProfileRequestModel implements IActivateInitProfileRequestModel {
    nickname?: string | undefined;

    constructor(data?: IActivateInitProfileRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nickname = _data["nickname"];
        }
    }

    static fromJS(data: any): ActivateInitProfileRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateInitProfileRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickname"] = this.nickname;
        return data;
    }
}

export interface IActivateInitProfileRequestModel {
    nickname?: string | undefined;
}

export class AlbumListRequestModel implements IAlbumListRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
    area?: string | undefined;
    type?: number;

    constructor(data?: IAlbumListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
            this.area = _data["area"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AlbumListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AlbumListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        data["area"] = this.area;
        data["type"] = this.type;
        return data;
    }
}

export interface IAlbumListRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
    area?: string | undefined;
    type?: number;
}

export class AlbumNewRequestModel implements IAlbumNewRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
    area?: string | undefined;

    constructor(data?: IAlbumNewRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
            this.area = _data["area"];
        }
    }

    static fromJS(data: any): AlbumNewRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AlbumNewRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        data["area"] = this.area;
        return data;
    }
}

export interface IAlbumNewRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
    area?: string | undefined;
}

export class AlbumSongsaleboardRequestModel implements IAlbumSongsaleboardRequestModel {
    albumType?: number;
    type?: string | undefined;
    year?: number | undefined;

    constructor(data?: IAlbumSongsaleboardRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.albumType = _data["albumType"];
            this.type = _data["type"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): AlbumSongsaleboardRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AlbumSongsaleboardRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["albumType"] = this.albumType;
        data["type"] = this.type;
        data["year"] = this.year;
        return data;
    }
}

export interface IAlbumSongsaleboardRequestModel {
    albumType?: number;
    type?: string | undefined;
    year?: number | undefined;
}

export class AlbumSublistRequestModel implements IAlbumSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IAlbumSublistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): AlbumSublistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AlbumSublistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IAlbumSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class ArtistAlbumRequestModel implements IArtistAlbumRequestModel {
    limit?: number;
    offset?: number;
    artistId?: number;
    total?: boolean;

    constructor(data?: IArtistAlbumRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.artistId = _data["artistId"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ArtistAlbumRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistAlbumRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["artistId"] = this.artistId;
        data["total"] = this.total;
        return data;
    }
}

export interface IArtistAlbumRequestModel {
    limit?: number;
    offset?: number;
    artistId?: number;
    total?: boolean;
}

export class ArtistListRequestModel implements IArtistListRequestModel {
    type?: number;
    area?: number;
    initial?: string | undefined;
    offset?: number;
    limit?: number;
    total?: boolean;

    constructor(data?: IArtistListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.area = _data["area"];
            this.initial = _data["initial"];
            this.offset = _data["offset"];
            this.limit = _data["limit"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ArtistListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["area"] = this.area;
        data["initial"] = this.initial;
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        data["total"] = this.total;
        return data;
    }
}

export interface IArtistListRequestModel {
    type?: number;
    area?: number;
    initial?: string | undefined;
    offset?: number;
    limit?: number;
    total?: boolean;
}

export class ArtistMvRequestModel implements IArtistMvRequestModel {
    artistId?: number;
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IArtistMvRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artistId = _data["artistId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ArtistMvRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistMvRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artistId"] = this.artistId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IArtistMvRequestModel {
    artistId?: number;
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class ArtistNewMvRequestModel implements IArtistNewMvRequestModel {
    limit?: number;
    startTimestamp?: number;

    constructor(data?: IArtistNewMvRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.startTimestamp = _data["startTimestamp"];
        }
    }

    static fromJS(data: any): ArtistNewMvRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistNewMvRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["startTimestamp"] = this.startTimestamp;
        return data;
    }
}

export interface IArtistNewMvRequestModel {
    limit?: number;
    startTimestamp?: number;
}

export class ArtistNewSongRequestModel implements IArtistNewSongRequestModel {
    limit?: number;
    startTimestamp?: number;

    constructor(data?: IArtistNewSongRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.startTimestamp = _data["startTimestamp"];
        }
    }

    static fromJS(data: any): ArtistNewSongRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistNewSongRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["startTimestamp"] = this.startTimestamp;
        return data;
    }
}

export interface IArtistNewSongRequestModel {
    limit?: number;
    startTimestamp?: number;
}

export class ArtistSongsRequestModel implements IArtistSongsRequestModel {
    artistId?: number;
    privateCloud?: string | undefined;
    workType?: number;
    order?: string | undefined;
    offset?: number;
    limit?: number;

    constructor(data?: IArtistSongsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artistId = _data["artistId"];
            this.privateCloud = _data["privateCloud"];
            this.workType = _data["workType"];
            this.order = _data["order"];
            this.offset = _data["offset"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): ArtistSongsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistSongsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artistId"] = this.artistId;
        data["privateCloud"] = this.privateCloud;
        data["workType"] = this.workType;
        data["order"] = this.order;
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IArtistSongsRequestModel {
    artistId?: number;
    privateCloud?: string | undefined;
    workType?: number;
    order?: string | undefined;
    offset?: number;
    limit?: number;
}

export class ArtistSublistRequestModel implements IArtistSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IArtistSublistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ArtistSublistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistSublistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IArtistSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class ArtistVideoRequestModel implements IArtistVideoRequestModel {
    artistId?: number;
    page?: PageInfo;
    tab?: number;
    order?: number;

    constructor(data?: IArtistVideoRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artistId = _data["artistId"];
            this.page = _data["page"] ? PageInfo.fromJS(_data["page"]) : <any>undefined;
            this.tab = _data["tab"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): ArtistVideoRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArtistVideoRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artistId"] = this.artistId;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        data["tab"] = this.tab;
        data["order"] = this.order;
        return data;
    }
}

export interface IArtistVideoRequestModel {
    artistId?: number;
    page?: PageInfo;
    tab?: number;
    order?: number;
}

export class AudioMatchRequestModel implements IAudioMatchRequestModel {
    duration?: number;
    audioFingerprint?: string | undefined;

    constructor(data?: IAudioMatchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.duration = _data["duration"];
            this.audioFingerprint = _data["audioFingerprint"];
        }
    }

    static fromJS(data: any): AudioMatchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AudioMatchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duration"] = this.duration;
        data["audioFingerprint"] = this.audioFingerprint;
        return data;
    }
}

export interface IAudioMatchRequestModel {
    duration?: number;
    audioFingerprint?: string | undefined;
}

export class AvatarUploadRequestModel implements IAvatarUploadRequestModel {
    imageData?: string | undefined;

    constructor(data?: IAvatarUploadRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageData = _data["imageData"];
        }
    }

    static fromJS(data: any): AvatarUploadRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new AvatarUploadRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageData"] = this.imageData;
        return data;
    }
}

export interface IAvatarUploadRequestModel {
    imageData?: string | undefined;
}

export class BatchRequestModel implements IBatchRequestModel {
    batchRequests?: { [key: string]: any; } | undefined;

    constructor(data?: IBatchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["batchRequests"]) {
                this.batchRequests = {} as any;
                for (let key in _data["batchRequests"]) {
                    if (_data["batchRequests"].hasOwnProperty(key))
                        (<any>this.batchRequests)![key] = _data["batchRequests"][key];
                }
            }
        }
    }

    static fromJS(data: any): BatchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new BatchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.batchRequests) {
            data["batchRequests"] = {};
            for (let key in this.batchRequests) {
                if (this.batchRequests.hasOwnProperty(key))
                    (<any>data["batchRequests"])[key] = (<any>this.batchRequests)[key];
            }
        }
        return data;
    }
}

export interface IBatchRequestModel {
    batchRequests?: { [key: string]: any; } | undefined;
}

export class BindingCellphoneRequestModel implements IBindingCellphoneRequestModel {
    phone?: string | undefined;
    countryCode?: string | undefined;
    captcha?: string | undefined;
    password?: string | undefined;

    constructor(data?: IBindingCellphoneRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.countryCode = _data["countryCode"];
            this.captcha = _data["captcha"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): BindingCellphoneRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new BindingCellphoneRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        data["captcha"] = this.captcha;
        data["password"] = this.password;
        return data;
    }
}

export interface IBindingCellphoneRequestModel {
    phone?: string | undefined;
    countryCode?: string | undefined;
    captcha?: string | undefined;
    password?: string | undefined;
}

export class CalendarRequestModel implements ICalendarRequestModel {
    startTime?: number;
    endTime?: number;

    constructor(data?: ICalendarRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
        }
    }

    static fromJS(data: any): CalendarRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        return data;
    }
}

export interface ICalendarRequestModel {
    startTime?: number;
    endTime?: number;
}

export class CaptchaVerifyRequestModel implements ICaptchaVerifyRequestModel {
    ctcode?: string | undefined;
    cellphone?: string | undefined;
    captcha?: string | undefined;

    constructor(data?: ICaptchaVerifyRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ctcode = _data["ctcode"];
            this.cellphone = _data["cellphone"];
            this.captcha = _data["captcha"];
        }
    }

    static fromJS(data: any): CaptchaVerifyRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CaptchaVerifyRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ctcode"] = this.ctcode;
        data["cellphone"] = this.cellphone;
        data["captcha"] = this.captcha;
        return data;
    }
}

export interface ICaptchaVerifyRequestModel {
    ctcode?: string | undefined;
    cellphone?: string | undefined;
    captcha?: string | undefined;
}

export class CellphoneExistenceCheckRequestModel implements ICellphoneExistenceCheckRequestModel {
    cellphone?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: ICellphoneExistenceCheckRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cellphone = _data["cellphone"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CellphoneExistenceCheckRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CellphoneExistenceCheckRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cellphone"] = this.cellphone;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

export interface ICellphoneExistenceCheckRequestModel {
    cellphone?: string | undefined;
    countryCode?: string | undefined;
}

export class CheckMusicRequestModel implements ICheckMusicRequestModel {
    musicId?: number;
    bitrate?: number;

    constructor(data?: ICheckMusicRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.musicId = _data["musicId"];
            this.bitrate = _data["bitrate"];
        }
    }

    static fromJS(data: any): CheckMusicRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CheckMusicRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["musicId"] = this.musicId;
        data["bitrate"] = this.bitrate;
        return data;
    }
}

export interface ICheckMusicRequestModel {
    musicId?: number;
    bitrate?: number;
}

export class CloudSearchRequestModel implements ICloudSearchRequestModel {
    keywords?: string | undefined;
    limit?: number;
    offset?: number;
    type?: string | undefined;
    total?: boolean;

    constructor(data?: ICloudSearchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keywords = _data["keywords"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.type = _data["type"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): CloudSearchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CloudSearchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["type"] = this.type;
        data["total"] = this.total;
        return data;
    }
}

export interface ICloudSearchRequestModel {
    keywords?: string | undefined;
    limit?: number;
    offset?: number;
    type?: string | undefined;
    total?: boolean;
}

export class CommentFloorRequestModel implements ICommentFloorRequestModel {
    parentCommentId?: string | undefined;
    threadId?: string | undefined;
    time?: number;
    limit?: number;
    id?: number;

    constructor(data?: ICommentFloorRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCommentId = _data["parentCommentId"];
            this.threadId = _data["threadId"];
            this.time = _data["time"];
            this.limit = _data["limit"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommentFloorRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentFloorRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCommentId"] = this.parentCommentId;
        data["threadId"] = this.threadId;
        data["time"] = this.time;
        data["limit"] = this.limit;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommentFloorRequestModel {
    parentCommentId?: string | undefined;
    threadId?: string | undefined;
    time?: number;
    limit?: number;
    id?: number;
}

export class CommentHugListRequestModel implements ICommentHugListRequestModel {
    targetUserId?: string | undefined;
    commentId?: string | undefined;
    cursor?: string | undefined;
    threadId?: string | undefined;
    pageNo?: number;
    idCursor?: number;
    pageSize?: number;

    constructor(data?: ICommentHugListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.commentId = _data["commentId"];
            this.cursor = _data["cursor"];
            this.threadId = _data["threadId"];
            this.pageNo = _data["pageNo"];
            this.idCursor = _data["idCursor"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): CommentHugListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentHugListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["commentId"] = this.commentId;
        data["cursor"] = this.cursor;
        data["threadId"] = this.threadId;
        data["pageNo"] = this.pageNo;
        data["idCursor"] = this.idCursor;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface ICommentHugListRequestModel {
    targetUserId?: string | undefined;
    commentId?: string | undefined;
    cursor?: string | undefined;
    threadId?: string | undefined;
    pageNo?: number;
    idCursor?: number;
    pageSize?: number;
}

export class CommentLikeRequestModel implements ICommentLikeRequestModel {
    id?: number;
    threadId?: string | undefined;
    operation?: number;
    type?: ResourceType;

    constructor(data?: ICommentLikeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.threadId = _data["threadId"];
            this.operation = _data["operation"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CommentLikeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentLikeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["threadId"] = this.threadId;
        data["operation"] = this.operation;
        data["type"] = this.type;
        return data;
    }
}

export interface ICommentLikeRequestModel {
    id?: number;
    threadId?: string | undefined;
    operation?: number;
    type?: ResourceType;
}

export class CommentManageRequestModel implements ICommentManageRequestModel {
    action?: string | undefined;
    threadId?: string | undefined;
    content?: string | undefined;
    commentId?: number | undefined;
    type?: ResourceType;

    constructor(data?: ICommentManageRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.threadId = _data["threadId"];
            this.content = _data["content"];
            this.commentId = _data["commentId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CommentManageRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentManageRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["threadId"] = this.threadId;
        data["content"] = this.content;
        data["commentId"] = this.commentId;
        data["type"] = this.type;
        return data;
    }
}

export interface ICommentManageRequestModel {
    action?: string | undefined;
    threadId?: string | undefined;
    content?: string | undefined;
    commentId?: number | undefined;
    type?: ResourceType;
}

export class CommentNewRequestModel implements ICommentNewRequestModel {
    id?: number;
    type?: ResourceType;
    pageNo?: number;
    pageSize?: number;
    sortType?: number;
    cursor?: string | undefined;
    showInner?: boolean;
    threadId?: string | undefined;

    constructor(data?: ICommentNewRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.pageNo = _data["pageNo"];
            this.pageSize = _data["pageSize"];
            this.sortType = _data["sortType"];
            this.cursor = _data["cursor"];
            this.showInner = _data["showInner"];
            this.threadId = _data["threadId"];
        }
    }

    static fromJS(data: any): CommentNewRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentNewRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["pageNo"] = this.pageNo;
        data["pageSize"] = this.pageSize;
        data["sortType"] = this.sortType;
        data["cursor"] = this.cursor;
        data["showInner"] = this.showInner;
        data["threadId"] = this.threadId;
        return data;
    }
}

export interface ICommentNewRequestModel {
    id?: number;
    type?: ResourceType;
    pageNo?: number;
    pageSize?: number;
    sortType?: number;
    cursor?: string | undefined;
    showInner?: boolean;
    threadId?: string | undefined;
}

export class CommentRequestModel implements ICommentRequestModel {
    id?: string | undefined;
    limit?: number;
    offset?: number;
    beforeTime?: number;

    constructor(data?: ICommentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.beforeTime = _data["beforeTime"];
        }
    }

    static fromJS(data: any): CommentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["beforeTime"] = this.beforeTime;
        return data;
    }
}

export interface ICommentRequestModel {
    id?: string | undefined;
    limit?: number;
    offset?: number;
    beforeTime?: number;
}

export class DigitalAlbumOrderRequestModel implements IDigitalAlbumOrderRequestModel {
    paymentMethod?: string | undefined;
    albumId?: number;
    quantity?: number;
    from?: string | undefined;
    digitalResources?: string | undefined;
    business?: string | undefined;

    constructor(data?: IDigitalAlbumOrderRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethod = _data["paymentMethod"];
            this.albumId = _data["albumId"];
            this.quantity = _data["quantity"];
            this.from = _data["from"];
            this.digitalResources = _data["digitalResources"];
            this.business = _data["business"];
        }
    }

    static fromJS(data: any): DigitalAlbumOrderRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalAlbumOrderRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod;
        data["albumId"] = this.albumId;
        data["quantity"] = this.quantity;
        data["from"] = this.from;
        data["digitalResources"] = this.digitalResources;
        data["business"] = this.business;
        return data;
    }
}

export interface IDigitalAlbumOrderRequestModel {
    paymentMethod?: string | undefined;
    albumId?: number;
    quantity?: number;
    from?: string | undefined;
    digitalResources?: string | undefined;
    business?: string | undefined;
}

export class FansCenterTrendRequestModel implements IFansCenterTrendRequestModel {
    startTime?: number;
    endTime?: number;
    type?: number;

    constructor(data?: IFansCenterTrendRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FansCenterTrendRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new FansCenterTrendRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["type"] = this.type;
        return data;
    }
}

export interface IFansCenterTrendRequestModel {
    startTime?: number;
    endTime?: number;
    type?: number;
}

export class HistoryRecommendSongsDetailRequestModel implements IHistoryRecommendSongsDetailRequestModel {
    date?: string | undefined;

    constructor(data?: IHistoryRecommendSongsDetailRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
        }
    }

    static fromJS(data: any): HistoryRecommendSongsDetailRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryRecommendSongsDetailRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        return data;
    }
}

export interface IHistoryRecommendSongsDetailRequestModel {
    date?: string | undefined;
}

export class HomepageBlockPageRequestModel implements IHomepageBlockPageRequestModel {
    refresh?: boolean;
    cursor?: string | undefined;

    constructor(data?: IHomepageBlockPageRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refresh = _data["refresh"];
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): HomepageBlockPageRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new HomepageBlockPageRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh"] = this.refresh;
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface IHomepageBlockPageRequestModel {
    refresh?: boolean;
    cursor?: string | undefined;
}

export class ListenDataRealtimeReportRequestModel implements IListenDataRealtimeReportRequestModel {
    type?: string | undefined;

    constructor(data?: IListenDataRealtimeReportRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ListenDataRealtimeReportRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenDataRealtimeReportRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

export interface IListenDataRealtimeReportRequestModel {
    type?: string | undefined;
}

export class ListenDataReportRequestModel implements IListenDataReportRequestModel {
    type?: string | undefined;
    endTime?: number;

    constructor(data?: IListenDataReportRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.endTime = _data["endTime"];
        }
    }

    static fromJS(data: any): ListenDataReportRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenDataReportRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["endTime"] = this.endTime;
        return data;
    }
}

export interface IListenDataReportRequestModel {
    type?: string | undefined;
    endTime?: number;
}

export class ListenTogetherAcceptRequestModel implements IListenTogetherAcceptRequestModel {
    roomId?: number;
    inviterId?: number;
    refer?: string | undefined;

    constructor(data?: IListenTogetherAcceptRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.inviterId = _data["inviterId"];
            this.refer = _data["refer"];
        }
    }

    static fromJS(data: any): ListenTogetherAcceptRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenTogetherAcceptRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["inviterId"] = this.inviterId;
        data["refer"] = this.refer;
        return data;
    }
}

export interface IListenTogetherAcceptRequestModel {
    roomId?: number;
    inviterId?: number;
    refer?: string | undefined;
}

export class ListenTogetherHeartbeatRequestModel implements IListenTogetherHeartbeatRequestModel {
    roomId?: number;
    songId?: number;
    playStatus?: string | undefined;
    progress?: number;

    constructor(data?: IListenTogetherHeartbeatRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.songId = _data["songId"];
            this.playStatus = _data["playStatus"];
            this.progress = _data["progress"];
        }
    }

    static fromJS(data: any): ListenTogetherHeartbeatRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenTogetherHeartbeatRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["songId"] = this.songId;
        data["playStatus"] = this.playStatus;
        data["progress"] = this.progress;
        return data;
    }
}

export interface IListenTogetherHeartbeatRequestModel {
    roomId?: number;
    songId?: number;
    playStatus?: string | undefined;
    progress?: number;
}

export class ListenTogetherPlayCommandInfo implements IListenTogetherPlayCommandInfo {
    commandType?: number;
    progress?: number;
    playStatus?: boolean;
    formerSongId?: number;
    targetSongId?: number;
    clientSeq?: string | undefined;

    constructor(data?: IListenTogetherPlayCommandInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandType = _data["commandType"];
            this.progress = _data["progress"];
            this.playStatus = _data["playStatus"];
            this.formerSongId = _data["formerSongId"];
            this.targetSongId = _data["targetSongId"];
            this.clientSeq = _data["clientSeq"];
        }
    }

    static fromJS(data: any): ListenTogetherPlayCommandInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ListenTogetherPlayCommandInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandType"] = this.commandType;
        data["progress"] = this.progress;
        data["playStatus"] = this.playStatus;
        data["formerSongId"] = this.formerSongId;
        data["targetSongId"] = this.targetSongId;
        data["clientSeq"] = this.clientSeq;
        return data;
    }
}

export interface IListenTogetherPlayCommandInfo {
    commandType?: number;
    progress?: number;
    playStatus?: boolean;
    formerSongId?: number;
    targetSongId?: number;
    clientSeq?: string | undefined;
}

export class ListenTogetherPlayCommandRequestModel implements IListenTogetherPlayCommandRequestModel {
    roomId?: number;
    commandInfo?: ListenTogetherPlayCommandInfo;

    constructor(data?: IListenTogetherPlayCommandRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.commandInfo = _data["commandInfo"] ? ListenTogetherPlayCommandInfo.fromJS(_data["commandInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListenTogetherPlayCommandRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenTogetherPlayCommandRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["commandInfo"] = this.commandInfo ? this.commandInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IListenTogetherPlayCommandRequestModel {
    roomId?: number;
    commandInfo?: ListenTogetherPlayCommandInfo;
}

export class ListenTogetherSyncCommandRequestModel implements IListenTogetherSyncCommandRequestModel {
    roomId?: number;
    playlistParam?: string | undefined;

    constructor(data?: IListenTogetherSyncCommandRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.playlistParam = _data["playlistParam"];
        }
    }

    static fromJS(data: any): ListenTogetherSyncCommandRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListenTogetherSyncCommandRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["playlistParam"] = this.playlistParam;
        return data;
    }
}

export interface IListenTogetherSyncCommandRequestModel {
    roomId?: number;
    playlistParam?: string | undefined;
}

export class LoginCellphoneRequestModel implements ILoginCellphoneRequestModel {
    phone?: string | undefined;
    countryCode?: string | undefined;
    passwordOrCaptcha?: string | undefined;
    type?: string | undefined;
    https?: string | undefined;
    captch?: number;
    password?: string | undefined;
    passwordMd5ed?: string | undefined;
    rememberLogin?: string | undefined;

    constructor(data?: ILoginCellphoneRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.countryCode = _data["countryCode"];
            this.passwordOrCaptcha = _data["passwordOrCaptcha"];
            this.type = _data["type"];
            this.https = _data["https"];
            this.captch = _data["captch"];
            this.password = _data["password"];
            this.passwordMd5ed = _data["passwordMd5ed"];
            this.rememberLogin = _data["rememberLogin"];
        }
    }

    static fromJS(data: any): LoginCellphoneRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCellphoneRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        data["passwordOrCaptcha"] = this.passwordOrCaptcha;
        data["type"] = this.type;
        data["https"] = this.https;
        data["captch"] = this.captch;
        data["password"] = this.password;
        data["passwordMd5ed"] = this.passwordMd5ed;
        data["rememberLogin"] = this.rememberLogin;
        return data;
    }
}

export interface ILoginCellphoneRequestModel {
    phone?: string | undefined;
    countryCode?: string | undefined;
    passwordOrCaptcha?: string | undefined;
    type?: string | undefined;
    https?: string | undefined;
    captch?: number;
    password?: string | undefined;
    passwordMd5ed?: string | undefined;
    rememberLogin?: string | undefined;
}

export class LoginRequestModel implements ILoginRequestModel {
    type?: string | undefined;
    https?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    rememberLogin?: string | undefined;

    constructor(data?: ILoginRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.https = _data["https"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.rememberLogin = _data["rememberLogin"];
        }
    }

    static fromJS(data: any): LoginRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["https"] = this.https;
        data["username"] = this.username;
        data["password"] = this.password;
        data["rememberLogin"] = this.rememberLogin;
        return data;
    }
}

export interface ILoginRequestModel {
    type?: string | undefined;
    https?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    rememberLogin?: string | undefined;
}

export class MlogMusicRcmdRequestModel implements IMlogMusicRcmdRequestModel {
    mvId?: number;
    songId?: number;
    limit?: number;
    recommendationType?: number;
    readonly extendedInfo?: string | undefined;

    constructor(data?: IMlogMusicRcmdRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mvId = _data["mvId"];
            this.songId = _data["songId"];
            this.limit = _data["limit"];
            this.recommendationType = _data["recommendationType"];
            (<any>this).extendedInfo = _data["extendedInfo"];
        }
    }

    static fromJS(data: any): MlogMusicRcmdRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MlogMusicRcmdRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mvId"] = this.mvId;
        data["songId"] = this.songId;
        data["limit"] = this.limit;
        data["recommendationType"] = this.recommendationType;
        data["extendedInfo"] = this.extendedInfo;
        return data;
    }
}

export interface IMlogMusicRcmdRequestModel {
    mvId?: number;
    songId?: number;
    limit?: number;
    recommendationType?: number;
    extendedInfo?: string | undefined;
}

export class MlogToVideoRequestModel implements IMlogToVideoRequestModel {
    mlogId?: number;

    constructor(data?: IMlogToVideoRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mlogId = _data["mlogId"];
        }
    }

    static fromJS(data: any): MlogToVideoRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MlogToVideoRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mlogId"] = this.mlogId;
        return data;
    }
}

export interface IMlogToVideoRequestModel {
    mlogId?: number;
}

export class MlogUrlRequestModel implements IMlogUrlRequestModel {
    id?: number;
    resolution?: number;
    type?: number;

    constructor(data?: IMlogUrlRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resolution = _data["resolution"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): MlogUrlRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MlogUrlRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resolution"] = this.resolution;
        data["type"] = this.type;
        return data;
    }
}

export interface IMlogUrlRequestModel {
    id?: number;
    resolution?: number;
    type?: number;
}

export class MsgCommentsRequestModel implements IMsgCommentsRequestModel {
    userId?: number;
    beforeTime?: string | undefined;
    limit?: number;

    constructor(data?: IMsgCommentsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.beforeTime = _data["beforeTime"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): MsgCommentsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MsgCommentsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["beforeTime"] = this.beforeTime;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IMsgCommentsRequestModel {
    userId?: number;
    beforeTime?: string | undefined;
    limit?: number;
}

export class MsgForwardsRequestModel implements IMsgForwardsRequestModel {
    offset?: number;
    limit?: number;

    constructor(data?: IMsgForwardsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): MsgForwardsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MsgForwardsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IMsgForwardsRequestModel {
    offset?: number;
    limit?: number;
}

export class MsgNoticesRequestModel implements IMsgNoticesRequestModel {
    limit?: number;
    lastTime?: number;

    constructor(data?: IMsgNoticesRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.lastTime = _data["lastTime"];
        }
    }

    static fromJS(data: any): MsgNoticesRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MsgNoticesRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["lastTime"] = this.lastTime;
        return data;
    }
}

export interface IMsgNoticesRequestModel {
    limit?: number;
    lastTime?: number;
}

export class MsgPrivateHistoryRequestModel implements IMsgPrivateHistoryRequestModel {
    userId?: number;
    limit?: number;
    beforeTime?: number;

    constructor(data?: IMsgPrivateHistoryRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.limit = _data["limit"];
            this.beforeTime = _data["beforeTime"];
        }
    }

    static fromJS(data: any): MsgPrivateHistoryRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MsgPrivateHistoryRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["limit"] = this.limit;
        data["beforeTime"] = this.beforeTime;
        return data;
    }
}

export interface IMsgPrivateHistoryRequestModel {
    userId?: number;
    limit?: number;
    beforeTime?: number;
}

export class MsgPrivateRequestModel implements IMsgPrivateRequestModel {
    offset?: number;
    limit?: number;

    constructor(data?: IMsgPrivateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): MsgPrivateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MsgPrivateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IMsgPrivateRequestModel {
    offset?: number;
    limit?: number;
}

export class MusicianCloudbeanClaimRequestModel implements IMusicianCloudbeanClaimRequestModel {
    missionId?: number;
    period?: string | undefined;

    constructor(data?: IMusicianCloudbeanClaimRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.missionId = _data["missionId"];
            this.period = _data["period"];
        }
    }

    static fromJS(data: any): MusicianCloudbeanClaimRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MusicianCloudbeanClaimRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missionId"] = this.missionId;
        data["period"] = this.period;
        return data;
    }
}

export interface IMusicianCloudbeanClaimRequestModel {
    missionId?: number;
    period?: string | undefined;
}

export class MusicianPlayTrendRequestModel implements IMusicianPlayTrendRequestModel {
    startTime?: number;
    endTime?: number;

    constructor(data?: IMusicianPlayTrendRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
        }
    }

    static fromJS(data: any): MusicianPlayTrendRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MusicianPlayTrendRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        return data;
    }
}

export interface IMusicianPlayTrendRequestModel {
    startTime?: number;
    endTime?: number;
}

export class MvAllRequestModel implements IMvAllRequestModel {
    area?: string | undefined;
    type?: string | undefined;
    order?: string | undefined;
    limit?: number;
    offset?: number;

    constructor(data?: IMvAllRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.type = _data["type"];
            this.order = _data["order"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): MvAllRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MvAllRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["type"] = this.type;
        data["order"] = this.order;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IMvAllRequestModel {
    area?: string | undefined;
    type?: string | undefined;
    order?: string | undefined;
    limit?: number;
    offset?: number;
}

export class MvFirstRequestModel implements IMvFirstRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;

    constructor(data?: IMvFirstRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): MvFirstRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MvFirstRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IMvFirstRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;
}

export class MvSubscribeRequestModel implements IMvSubscribeRequestModel {
    mvId?: number;
    operation?: number;

    constructor(data?: IMvSubscribeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mvId = _data["mvId"];
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): MvSubscribeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MvSubscribeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mvId"] = this.mvId;
        data["operation"] = this.operation;
        return data;
    }
}

export interface IMvSubscribeRequestModel {
    mvId?: number;
    operation?: number;
}

export class MvUrlRequestModel implements IMvUrlRequestModel {
    id?: number;
    resolution?: number;

    constructor(data?: IMvUrlRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resolution = _data["resolution"];
        }
    }

    static fromJS(data: any): MvUrlRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new MvUrlRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resolution"] = this.resolution;
        return data;
    }
}

export interface IMvUrlRequestModel {
    id?: number;
    resolution?: number;
}

export class PageInfo implements IPageInfo {
    size?: number;
    cursor?: number;

    constructor(data?: IPageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): PageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface IPageInfo {
    size?: number;
    cursor?: number;
}

export class PaginatedRequestModel implements IPaginatedRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IPaginatedRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): PaginatedRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IPaginatedRequestModel {
    limit?: number;
    offset?: number;
}

export class PaginationModel implements IPaginationModel {
    size?: number;
    cursor?: number;

    constructor(data?: IPaginationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): PaginationModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface IPaginationModel {
    size?: number;
    cursor?: number;
}

export class PersonalFmModeRequestModel implements IPersonalFmModeRequestModel {
    mode?: string | undefined;
    subMode?: string | undefined;
    limit?: number;

    constructor(data?: IPersonalFmModeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mode = _data["mode"];
            this.subMode = _data["subMode"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): PersonalFmModeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFmModeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode;
        data["subMode"] = this.subMode;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IPersonalFmModeRequestModel {
    mode?: string | undefined;
    subMode?: string | undefined;
    limit?: number;
}

export class PersonalizedNewsongRequestModel implements IPersonalizedNewsongRequestModel {
    limit?: number;
    areaId?: number;

    constructor(data?: IPersonalizedNewsongRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): PersonalizedNewsongRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalizedNewsongRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["areaId"] = this.areaId;
        return data;
    }
}

export interface IPersonalizedNewsongRequestModel {
    limit?: number;
    areaId?: number;
}

export class PersonalizedPrivatecontentListRequestModel implements IPersonalizedPrivatecontentListRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IPersonalizedPrivatecontentListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): PersonalizedPrivatecontentListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalizedPrivatecontentListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IPersonalizedPrivatecontentListRequestModel {
    limit?: number;
    offset?: number;
}

export class PersonalizedRequestModel implements IPersonalizedRequestModel {
    limit?: number;
    total?: boolean;
    advancedCustomization?: number;

    constructor(data?: IPersonalizedRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.total = _data["total"];
            this.advancedCustomization = _data["advancedCustomization"];
        }
    }

    static fromJS(data: any): PersonalizedRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalizedRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["total"] = this.total;
        data["advancedCustomization"] = this.advancedCustomization;
        return data;
    }
}

export interface IPersonalizedRequestModel {
    limit?: number;
    total?: boolean;
    advancedCustomization?: number;
}

export class PlaylistCoverUpdateRequestModel implements IPlaylistCoverUpdateRequestModel {
    playlistId?: number;
    imgFile?: string | undefined;
    imgFileName?: string | undefined;

    constructor(data?: IPlaylistCoverUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.imgFile = _data["imgFile"];
            this.imgFileName = _data["imgFileName"];
        }
    }

    static fromJS(data: any): PlaylistCoverUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistCoverUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["imgFile"] = this.imgFile;
        data["imgFileName"] = this.imgFileName;
        return data;
    }
}

export interface IPlaylistCoverUpdateRequestModel {
    playlistId?: number;
    imgFile?: string | undefined;
    imgFileName?: string | undefined;
}

export class PlaylistCreateRequestModel implements IPlaylistCreateRequestModel {
    name?: string | undefined;
    privacy?: string | undefined;
    type?: string | undefined;

    constructor(data?: IPlaylistCreateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.privacy = _data["privacy"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PlaylistCreateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistCreateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["privacy"] = this.privacy;
        data["type"] = this.type;
        return data;
    }
}

export interface IPlaylistCreateRequestModel {
    name?: string | undefined;
    privacy?: string | undefined;
    type?: string | undefined;
}

export class PlaylistDescUpdateRequestModel implements IPlaylistDescUpdateRequestModel {
    playlistId?: number;
    description?: string | undefined;

    constructor(data?: IPlaylistDescUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PlaylistDescUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistDescUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["description"] = this.description;
        return data;
    }
}

export interface IPlaylistDescUpdateRequestModel {
    playlistId?: number;
    description?: string | undefined;
}

export class PlaylistDetailRcmdRequestModel implements IPlaylistDetailRcmdRequestModel {
    playlistId?: number;

    constructor(data?: IPlaylistDetailRcmdRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
        }
    }

    static fromJS(data: any): PlaylistDetailRcmdRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistDetailRcmdRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        return data;
    }
}

export interface IPlaylistDetailRcmdRequestModel {
    playlistId?: number;
}

export class PlaylistDetailRequestModel implements IPlaylistDetailRequestModel {
    playlistId?: number;
    subscriberLimit?: number;
    songLimit?: number;

    constructor(data?: IPlaylistDetailRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.subscriberLimit = _data["subscriberLimit"];
            this.songLimit = _data["songLimit"];
        }
    }

    static fromJS(data: any): PlaylistDetailRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistDetailRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["subscriberLimit"] = this.subscriberLimit;
        data["songLimit"] = this.songLimit;
        return data;
    }
}

export interface IPlaylistDetailRequestModel {
    playlistId?: number;
    subscriberLimit?: number;
    songLimit?: number;
}

export class PlaylistImportNameTaskRequestModel implements IPlaylistImportNameTaskRequestModel {
    importStarPlaylist?: boolean;
    local?: string | undefined;
    text?: string | undefined;
    link?: string | undefined;
    playlistName?: string | undefined;

    constructor(data?: IPlaylistImportNameTaskRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importStarPlaylist = _data["importStarPlaylist"];
            this.local = _data["local"];
            this.text = _data["text"];
            this.link = _data["link"];
            this.playlistName = _data["playlistName"];
        }
    }

    static fromJS(data: any): PlaylistImportNameTaskRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistImportNameTaskRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importStarPlaylist"] = this.importStarPlaylist;
        data["local"] = this.local;
        data["text"] = this.text;
        data["link"] = this.link;
        data["playlistName"] = this.playlistName;
        return data;
    }
}

export interface IPlaylistImportNameTaskRequestModel {
    importStarPlaylist?: boolean;
    local?: string | undefined;
    text?: string | undefined;
    link?: string | undefined;
    playlistName?: string | undefined;
}

export class PlaylistMyLikeRequestModel implements IPlaylistMyLikeRequestModel {
    time?: string | undefined;
    limit?: number;

    constructor(data?: IPlaylistMyLikeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): PlaylistMyLikeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistMyLikeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IPlaylistMyLikeRequestModel {
    time?: string | undefined;
    limit?: number;
}

export class PlaylistNameUpdateRequestModel implements IPlaylistNameUpdateRequestModel {
    playlistId?: number;
    newName?: string | undefined;

    constructor(data?: IPlaylistNameUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.newName = _data["newName"];
        }
    }

    static fromJS(data: any): PlaylistNameUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistNameUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["newName"] = this.newName;
        return data;
    }
}

export interface IPlaylistNameUpdateRequestModel {
    playlistId?: number;
    newName?: string | undefined;
}

export class PlaylistOrderUpdateRequestModel implements IPlaylistOrderUpdateRequestModel {
    playlistIds?: number[] | undefined;

    constructor(data?: IPlaylistOrderUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["playlistIds"])) {
                this.playlistIds = [] as any;
                for (let item of _data["playlistIds"])
                    this.playlistIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PlaylistOrderUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistOrderUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.playlistIds)) {
            data["playlistIds"] = [];
            for (let item of this.playlistIds)
                data["playlistIds"].push(item);
        }
        return data;
    }
}

export interface IPlaylistOrderUpdateRequestModel {
    playlistIds?: number[] | undefined;
}

export class PlaylistPrivacyRequestModel implements IPlaylistPrivacyRequestModel {
    playlistId?: number;
    privacySetting?: number;

    constructor(data?: IPlaylistPrivacyRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.privacySetting = _data["privacySetting"];
        }
    }

    static fromJS(data: any): PlaylistPrivacyRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistPrivacyRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["privacySetting"] = this.privacySetting;
        return data;
    }
}

export interface IPlaylistPrivacyRequestModel {
    playlistId?: number;
    privacySetting?: number;
}

export class PlaylistSubscribeRequestModel implements IPlaylistSubscribeRequestModel {
    playlistId?: number;
    operation?: number;

    constructor(data?: IPlaylistSubscribeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): PlaylistSubscribeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistSubscribeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["operation"] = this.operation;
        return data;
    }
}

export interface IPlaylistSubscribeRequestModel {
    playlistId?: number;
    operation?: number;
}

export class PlaylistSubscribersRequestModel implements IPlaylistSubscribersRequestModel {
    playlistId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: IPlaylistSubscribersRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): PlaylistSubscribersRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistSubscribersRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IPlaylistSubscribersRequestModel {
    playlistId?: number;
    limit?: number;
    offset?: number;
}

export class PlaylistTagsUpdateRequestModel implements IPlaylistTagsUpdateRequestModel {
    playlistId?: number;
    tags?: string[] | undefined;

    constructor(data?: IPlaylistTagsUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): PlaylistTagsUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistTagsUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IPlaylistTagsUpdateRequestModel {
    playlistId?: number;
    tags?: string[] | undefined;
}

export class PlaylistTrackAddRequestModel implements IPlaylistTrackAddRequestModel {
    playlistId?: number;
    trackIds?: TrackModel[] | undefined;

    constructor(data?: IPlaylistTrackAddRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            if (Array.isArray(_data["trackIds"])) {
                this.trackIds = [] as any;
                for (let item of _data["trackIds"])
                    this.trackIds!.push(TrackModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlaylistTrackAddRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistTrackAddRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        if (Array.isArray(this.trackIds)) {
            data["trackIds"] = [];
            for (let item of this.trackIds)
                data["trackIds"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlaylistTrackAddRequestModel {
    playlistId?: number;
    trackIds?: TrackModel[] | undefined;
}

export class PlaylistTrackAllRequestModel implements IPlaylistTrackAllRequestModel {
    playlistId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: IPlaylistTrackAllRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): PlaylistTrackAllRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistTrackAllRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IPlaylistTrackAllRequestModel {
    playlistId?: number;
    limit?: number;
    offset?: number;
}

export class PlaylistTracksManipulateRequestModel implements IPlaylistTracksManipulateRequestModel {
    playlistId?: number;
    trackIds?: number[] | undefined;
    operation?: string | undefined;

    constructor(data?: IPlaylistTracksManipulateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            if (Array.isArray(_data["trackIds"])) {
                this.trackIds = [] as any;
                for (let item of _data["trackIds"])
                    this.trackIds!.push(item);
            }
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): PlaylistTracksManipulateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistTracksManipulateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        if (Array.isArray(this.trackIds)) {
            data["trackIds"] = [];
            for (let item of this.trackIds)
                data["trackIds"].push(item);
        }
        data["operation"] = this.operation;
        return data;
    }
}

export interface IPlaylistTracksManipulateRequestModel {
    playlistId?: number;
    trackIds?: number[] | undefined;
    operation?: string | undefined;
}

export class PlaylistUpdateRequestModel implements IPlaylistUpdateRequestModel {
    playlistId?: number;
    name?: string | undefined;
    tags?: string[] | undefined;
    description?: string | undefined;

    constructor(data?: IPlaylistUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.name = _data["name"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PlaylistUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["name"] = this.name;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["description"] = this.description;
        return data;
    }
}

export interface IPlaylistUpdateRequestModel {
    playlistId?: number;
    name?: string | undefined;
    tags?: string[] | undefined;
    description?: string | undefined;
}

export class PlaymodeIntelligenceListRequestModel implements IPlaymodeIntelligenceListRequestModel {
    songId?: number;
    playlistId?: number;
    seedSongId?: number | undefined;
    count?: number;

    constructor(data?: IPlaymodeIntelligenceListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.playlistId = _data["playlistId"];
            this.seedSongId = _data["seedSongId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): PlaymodeIntelligenceListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaymodeIntelligenceListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["playlistId"] = this.playlistId;
        data["seedSongId"] = this.seedSongId;
        data["count"] = this.count;
        return data;
    }
}

export interface IPlaymodeIntelligenceListRequestModel {
    songId?: number;
    playlistId?: number;
    seedSongId?: number | undefined;
    count?: number;
}

export class PlaymodeSongVectorRequestModel implements IPlaymodeSongVectorRequestModel {
    songIds?: number[] | undefined;

    constructor(data?: IPlaymodeSongVectorRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["songIds"])) {
                this.songIds = [] as any;
                for (let item of _data["songIds"])
                    this.songIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PlaymodeSongVectorRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlaymodeSongVectorRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.songIds)) {
            data["songIds"] = [];
            for (let item of this.songIds)
                data["songIds"].push(item);
        }
        return data;
    }
}

export interface IPlaymodeSongVectorRequestModel {
    songIds?: number[] | undefined;
}

export class ProgramRecommendRequestModel implements IProgramRecommendRequestModel {
    categoryId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: IProgramRecommendRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): ProgramRecommendRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramRecommendRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IProgramRecommendRequestModel {
    categoryId?: number;
    limit?: number;
    offset?: number;
}

export class PurchasedAlbumsRequestModel implements IPurchasedAlbumsRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IPurchasedAlbumsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PurchasedAlbumsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasedAlbumsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IPurchasedAlbumsRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class RadioHotRequestModel implements IRadioHotRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IRadioHotRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): RadioHotRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioHotRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IRadioHotRequestModel {
    limit?: number;
    offset?: number;
}

export class RadioHotStationsRequestModel implements IRadioHotStationsRequestModel {
    categoryId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: IRadioHotStationsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): RadioHotStationsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioHotStationsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IRadioHotStationsRequestModel {
    categoryId?: number;
    limit?: number;
    offset?: number;
}

export class RadioLikeRequestModel implements IRadioLikeRequestModel {
    id?: number;
    like?: boolean;

    constructor(data?: IRadioLikeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.like = _data["like"];
        }
    }

    static fromJS(data: any): RadioLikeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioLikeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["like"] = this.like;
        return data;
    }
}

export interface IRadioLikeRequestModel {
    id?: number;
    like?: boolean;
}

export class RadioPayGiftRequestModel implements IRadioPayGiftRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IRadioPayGiftRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RadioPayGiftRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioPayGiftRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IRadioPayGiftRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class RadioProgramToplistRequestModel implements IRadioProgramToplistRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IRadioProgramToplistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): RadioProgramToplistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioProgramToplistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IRadioProgramToplistRequestModel {
    limit?: number;
    offset?: number;
}

export class RadioProgramsRequestModel implements IRadioProgramsRequestModel {
    radioId?: number;
    limit?: number;
    offset?: number;
    ascending?: boolean;

    constructor(data?: IRadioProgramsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.radioId = _data["radioId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.ascending = _data["ascending"];
        }
    }

    static fromJS(data: any): RadioProgramsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioProgramsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["radioId"] = this.radioId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["ascending"] = this.ascending;
        return data;
    }
}

export interface IRadioProgramsRequestModel {
    radioId?: number;
    limit?: number;
    offset?: number;
    ascending?: boolean;
}

export class RadioRankingRequestModel implements IRadioRankingRequestModel {
    djRadioId?: number | undefined;
    sortIndex?: number;
    dataGapDays?: number;
    dataType?: number;

    constructor(data?: IRadioRankingRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.djRadioId = _data["djRadioId"];
            this.sortIndex = _data["sortIndex"];
            this.dataGapDays = _data["dataGapDays"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): RadioRankingRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioRankingRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["djRadioId"] = this.djRadioId;
        data["sortIndex"] = this.sortIndex;
        data["dataGapDays"] = this.dataGapDays;
        data["dataType"] = this.dataType;
        return data;
    }
}

export interface IRadioRankingRequestModel {
    djRadioId?: number | undefined;
    sortIndex?: number;
    dataGapDays?: number;
    dataType?: number;
}

export class RadioSubscribersRequestModel implements IRadioSubscribersRequestModel {
    radioId?: number;
    time?: number;
    limit?: number;
    total?: boolean;

    constructor(data?: IRadioSubscribersRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.radioId = _data["radioId"];
            this.time = _data["time"];
            this.limit = _data["limit"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RadioSubscribersRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioSubscribersRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["radioId"] = this.radioId;
        data["time"] = this.time;
        data["limit"] = this.limit;
        data["total"] = this.total;
        return data;
    }
}

export interface IRadioSubscribersRequestModel {
    radioId?: number;
    time?: number;
    limit?: number;
    total?: boolean;
}

export class RadioSubscriptionRequestModel implements IRadioSubscriptionRequestModel {
    radioId?: number;
    subscriptionType?: number;

    constructor(data?: IRadioSubscriptionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.radioId = _data["radioId"];
            this.subscriptionType = _data["subscriptionType"];
        }
    }

    static fromJS(data: any): RadioSubscriptionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioSubscriptionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["radioId"] = this.radioId;
        data["subscriptionType"] = this.subscriptionType;
        return data;
    }
}

export interface IRadioSubscriptionRequestModel {
    radioId?: number;
    subscriptionType?: number;
}

export class RadioSubscriptionsRequestModel implements IRadioSubscriptionsRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: IRadioSubscriptionsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RadioSubscriptionsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioSubscriptionsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface IRadioSubscriptionsRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class RadioToplistRequestModel implements IRadioToplistRequestModel {
    limit?: number;
    offset?: number;
    type?: string | undefined;

    constructor(data?: IRadioToplistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): RadioToplistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioToplistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["type"] = this.type;
        return data;
    }
}

export interface IRadioToplistRequestModel {
    limit?: number;
    offset?: number;
    type?: string | undefined;
}

export class RadioTrashSongRequestModel implements IRadioTrashSongRequestModel {
    id?: number;
    time?: number;

    constructor(data?: IRadioTrashSongRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): RadioTrashSongRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RadioTrashSongRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["time"] = this.time;
        return data;
    }
}

export interface IRadioTrashSongRequestModel {
    id?: number;
    time?: number;
}

export class RecommendSongsDislikeRequestModel implements IRecommendSongsDislikeRequestModel {
    resId?: string | undefined;

    constructor(data?: IRecommendSongsDislikeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resId = _data["resId"];
        }
    }

    static fromJS(data: any): RecommendSongsDislikeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendSongsDislikeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resId"] = this.resId;
        return data;
    }
}

export interface IRecommendSongsDislikeRequestModel {
    resId?: string | undefined;
}

export class RegisterCellphoneRequestModel implements IRegisterCellphoneRequestModel {
    captcha?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    nickname?: string | undefined;
    countrycode?: number;

    constructor(data?: IRegisterCellphoneRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.captcha = _data["captcha"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.nickname = _data["nickname"];
            this.countrycode = _data["countrycode"];
        }
    }

    static fromJS(data: any): RegisterCellphoneRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCellphoneRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["captcha"] = this.captcha;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["nickname"] = this.nickname;
        data["countrycode"] = this.countrycode;
        return data;
    }
}

export interface IRegisterCellphoneRequestModel {
    captcha?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    nickname?: string | undefined;
    countrycode?: number;
}

export class ResourceLikeRequestModel implements IResourceLikeRequestModel {
    id?: string | undefined;
    type?: string | undefined;
    like?: boolean;
    threadId?: string | undefined;

    constructor(data?: IResourceLikeRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.like = _data["like"];
            this.threadId = _data["threadId"];
        }
    }

    static fromJS(data: any): ResourceLikeRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceLikeRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["like"] = this.like;
        data["threadId"] = this.threadId;
        return data;
    }
}

export interface IResourceLikeRequestModel {
    id?: string | undefined;
    type?: string | undefined;
    like?: boolean;
    threadId?: string | undefined;
}

export enum ResourceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class SearchInputModel implements ISearchInputModel {
    type?: SearchTypes;
    keywords?: string | undefined;
    limit?: number;
    offset?: number;

    constructor(data?: ISearchInputModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.keywords = _data["keywords"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): SearchInputModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInputModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["keywords"] = this.keywords;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ISearchInputModel {
    type?: SearchTypes;
    keywords?: string | undefined;
    limit?: number;
    offset?: number;
}

export class SearchMatchRequestModel implements ISearchMatchRequestModel {
    songs?: SearchMatchSongs[] | undefined;

    constructor(data?: ISearchMatchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["songs"])) {
                this.songs = [] as any;
                for (let item of _data["songs"])
                    this.songs!.push(SearchMatchSongs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchMatchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMatchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.songs)) {
            data["songs"] = [];
            for (let item of this.songs)
                data["songs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchMatchRequestModel {
    songs?: SearchMatchSongs[] | undefined;
}

export class SearchMatchSongs implements ISearchMatchSongs {
    title?: string | undefined;
    album?: string | undefined;
    artist?: string | undefined;
    duration?: number;
    md5?: string | undefined;

    constructor(data?: ISearchMatchSongs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.album = _data["album"];
            this.artist = _data["artist"];
            this.duration = _data["duration"];
            this.md5 = _data["md5"];
        }
    }

    static fromJS(data: any): SearchMatchSongs {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMatchSongs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["album"] = this.album;
        data["artist"] = this.artist;
        data["duration"] = this.duration;
        data["md5"] = this.md5;
        return data;
    }
}

export interface ISearchMatchSongs {
    title?: string | undefined;
    album?: string | undefined;
    artist?: string | undefined;
    duration?: number;
    md5?: string | undefined;
}

export enum SearchTypes {
    _1 = 1,
    _10 = 10,
    _100 = 100,
    _1000 = 1000,
    _1002 = 1002,
    _1004 = 1004,
    _1006 = 1006,
    _1009 = 1009,
    _1014 = 1014,
    _1018 = 1018,
    _2000 = 2000,
}

export class SendAlbumRequestModel implements ISendAlbumRequestModel {
    albumId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;

    constructor(data?: ISendAlbumRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.albumId = _data["albumId"];
            this.message = _data["message"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendAlbumRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendAlbumRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["albumId"] = this.albumId;
        data["message"] = this.message;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface ISendAlbumRequestModel {
    albumId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;
}

export class SendPlaylistRequestModel implements ISendPlaylistRequestModel {
    playlistId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;

    constructor(data?: ISendPlaylistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            this.message = _data["message"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendPlaylistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendPlaylistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        data["message"] = this.message;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface ISendPlaylistRequestModel {
    playlistId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;
}

export class SendSongRequestModel implements ISendSongRequestModel {
    songId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;

    constructor(data?: ISendSongRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.message = _data["message"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendSongRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendSongRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["message"] = this.message;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface ISendSongRequestModel {
    songId?: string | undefined;
    message?: string | undefined;
    userIds?: string[] | undefined;
}

export class SendTextRequestModel implements ISendTextRequestModel {
    message?: string | undefined;
    userIds?: string[] | undefined;

    constructor(data?: ISendTextRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendTextRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTextRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface ISendTextRequestModel {
    message?: string | undefined;
    userIds?: string[] | undefined;
}

export class ShareResourceRequestModel implements IShareResourceRequestModel {
    type?: string | undefined;
    message?: string | undefined;
    resourceId?: string | undefined;

    constructor(data?: IShareResourceRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.message = _data["message"];
            this.resourceId = _data["resourceId"];
        }
    }

    static fromJS(data: any): ShareResourceRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ShareResourceRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["message"] = this.message;
        data["resourceId"] = this.resourceId;
        return data;
    }
}

export interface IShareResourceRequestModel {
    type?: string | undefined;
    message?: string | undefined;
    resourceId?: string | undefined;
}

export class SheetListRequestModel implements ISheetListRequestModel {
    id?: string | undefined;
    abTest?: string | undefined;

    constructor(data?: ISheetListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.abTest = _data["abTest"];
        }
    }

    static fromJS(data: any): SheetListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SheetListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["abTest"] = this.abTest;
        return data;
    }
}

export interface ISheetListRequestModel {
    id?: string | undefined;
    abTest?: string | undefined;
}

export class SheetPreviewRequestModel implements ISheetPreviewRequestModel {
    id?: string | undefined;

    constructor(data?: ISheetPreviewRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SheetPreviewRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SheetPreviewRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ISheetPreviewRequestModel {
    id?: string | undefined;
}

export class SigninProgressRequestModel implements ISigninProgressRequestModel {
    moduleId?: string | undefined;

    constructor(data?: ISigninProgressRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
        }
    }

    static fromJS(data: any): SigninProgressRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SigninProgressRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        return data;
    }
}

export interface ISigninProgressRequestModel {
    moduleId?: string | undefined;
}

export class SimiPlaylistRequestModel implements ISimiPlaylistRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: ISimiPlaylistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): SimiPlaylistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SimiPlaylistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ISimiPlaylistRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;
}

export class SimiSongRequestModel implements ISimiSongRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: ISimiSongRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): SimiSongRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SimiSongRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ISimiSongRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;
}

export class SimiUserRequestModel implements ISimiUserRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;

    constructor(data?: ISimiUserRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): SimiUserRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SimiUserRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ISimiUserRequestModel {
    songId?: number;
    limit?: number;
    offset?: number;
}

export class SongDetailRequestModel implements ISongDetailRequestModel {
    ids?: number[] | undefined;

    constructor(data?: ISongDetailRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): SongDetailRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongDetailRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface ISongDetailRequestModel {
    ids?: number[] | undefined;
}

export class SongImportRequestModel implements ISongImportRequestModel {
    id?: number | undefined;
    md5?: string | undefined;
    bitrate?: number;
    fileSize?: number;
    song?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    fileType?: string | undefined;

    constructor(data?: ISongImportRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.md5 = _data["md5"];
            this.bitrate = _data["bitrate"];
            this.fileSize = _data["fileSize"];
            this.song = _data["song"];
            this.artist = _data["artist"];
            this.album = _data["album"];
            this.fileType = _data["fileType"];
        }
    }

    static fromJS(data: any): SongImportRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongImportRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["md5"] = this.md5;
        data["bitrate"] = this.bitrate;
        data["fileSize"] = this.fileSize;
        data["song"] = this.song;
        data["artist"] = this.artist;
        data["album"] = this.album;
        data["fileType"] = this.fileType;
        return data;
    }
}

export interface ISongImportRequestModel {
    id?: number | undefined;
    md5?: string | undefined;
    bitrate?: number;
    fileSize?: number;
    song?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    fileType?: string | undefined;
}

export class SongMatchRequestModel implements ISongMatchRequestModel {
    userId?: number;
    songId?: number;
    adjustedSongId?: number;

    constructor(data?: ISongMatchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.songId = _data["songId"];
            this.adjustedSongId = _data["adjustedSongId"];
        }
    }

    static fromJS(data: any): SongMatchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongMatchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["songId"] = this.songId;
        data["adjustedSongId"] = this.adjustedSongId;
        return data;
    }
}

export interface ISongMatchRequestModel {
    userId?: number;
    songId?: number;
    adjustedSongId?: number;
}

export class SongOrderUpdateRequestModel implements ISongOrderUpdateRequestModel {
    playlistId?: number;
    trackIds?: number[] | undefined;

    constructor(data?: ISongOrderUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlistId = _data["playlistId"];
            if (Array.isArray(_data["trackIds"])) {
                this.trackIds = [] as any;
                for (let item of _data["trackIds"])
                    this.trackIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SongOrderUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongOrderUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlistId"] = this.playlistId;
        if (Array.isArray(this.trackIds)) {
            data["trackIds"] = [];
            for (let item of this.trackIds)
                data["trackIds"].push(item);
        }
        return data;
    }
}

export interface ISongOrderUpdateRequestModel {
    playlistId?: number;
    trackIds?: number[] | undefined;
}

export class SongUploadRequestModel implements ISongUploadRequestModel {
    songName?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    fileType?: string | undefined;
    md5?: string | undefined;
    bitrate?: number;
    fileSize?: number;

    constructor(data?: ISongUploadRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songName = _data["songName"];
            this.artist = _data["artist"];
            this.album = _data["album"];
            this.fileType = _data["fileType"];
            this.md5 = _data["md5"];
            this.bitrate = _data["bitrate"];
            this.fileSize = _data["fileSize"];
        }
    }

    static fromJS(data: any): SongUploadRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongUploadRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songName"] = this.songName;
        data["artist"] = this.artist;
        data["album"] = this.album;
        data["fileType"] = this.fileType;
        data["md5"] = this.md5;
        data["bitrate"] = this.bitrate;
        data["fileSize"] = this.fileSize;
        return data;
    }
}

export interface ISongUploadRequestModel {
    songName?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    fileType?: string | undefined;
    md5?: string | undefined;
    bitrate?: number;
    fileSize?: number;
}

export class SongUrlRequestModel implements ISongUrlRequestModel {
    ids?: string | undefined;
    br?: string | undefined;

    constructor(data?: ISongUrlRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ids = _data["ids"];
            this.br = _data["br"];
        }
    }

    static fromJS(data: any): SongUrlRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongUrlRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ids"] = this.ids;
        data["br"] = this.br;
        return data;
    }
}

export interface ISongUrlRequestModel {
    ids?: string | undefined;
    br?: string | undefined;
}

export class SongUrlV1RequestModel implements ISongUrlV1RequestModel {
    ids?: string | undefined;
    level?: string | undefined;
    immerseType?: string | undefined;

    constructor(data?: ISongUrlV1RequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ids = _data["ids"];
            this.level = _data["level"];
            this.immerseType = _data["immerseType"];
        }
    }

    static fromJS(data: any): SongUrlV1RequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SongUrlV1RequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ids"] = this.ids;
        data["level"] = this.level;
        data["immerseType"] = this.immerseType;
        return data;
    }
}

export interface ISongUrlV1RequestModel {
    ids?: string | undefined;
    level?: string | undefined;
    immerseType?: string | undefined;
}

export class StyleRequestModel implements IStyleRequestModel {
    cursor?: number;
    size?: number;
    tagId?: number;
    sort?: number;

    constructor(data?: IStyleRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cursor = _data["cursor"];
            this.size = _data["size"];
            this.tagId = _data["tagId"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): StyleRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new StyleRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cursor"] = this.cursor;
        data["size"] = this.size;
        data["tagId"] = this.tagId;
        data["sort"] = this.sort;
        return data;
    }
}

export interface IStyleRequestModel {
    cursor?: number;
    size?: number;
    tagId?: number;
    sort?: number;
}

export class SummaryAnnualRequestModel implements ISummaryAnnualRequestModel {
    year?: number;

    constructor(data?: ISummaryAnnualRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): SummaryAnnualRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryAnnualRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        return data;
    }
}

export interface ISummaryAnnualRequestModel {
    year?: number;
}

export class TopAlbumRequestModel implements ITopAlbumRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;
    type?: string | undefined;
    year?: number;
    month?: number;

    constructor(data?: ITopAlbumRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.type = _data["type"];
            this.year = _data["year"];
            this.month = _data["month"];
        }
    }

    static fromJS(data: any): TopAlbumRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopAlbumRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["type"] = this.type;
        data["year"] = this.year;
        data["month"] = this.month;
        return data;
    }
}

export interface ITopAlbumRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;
    type?: string | undefined;
    year?: number;
    month?: number;
}

export class TopMvRequestModel implements ITopMvRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;

    constructor(data?: ITopMvRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): TopMvRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopMvRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ITopMvRequestModel {
    area?: string | undefined;
    limit?: number;
    offset?: number;
}

export class TopPlaylistHighqualityRequestModel implements ITopPlaylistHighqualityRequestModel {
    cat?: string | undefined;
    limit?: number;
    lastTime?: number;
    total?: boolean;

    constructor(data?: ITopPlaylistHighqualityRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cat = _data["cat"];
            this.limit = _data["limit"];
            this.lastTime = _data["lastTime"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): TopPlaylistHighqualityRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopPlaylistHighqualityRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cat"] = this.cat;
        data["limit"] = this.limit;
        data["lastTime"] = this.lastTime;
        data["total"] = this.total;
        return data;
    }
}

export interface ITopPlaylistHighqualityRequestModel {
    cat?: string | undefined;
    limit?: number;
    lastTime?: number;
    total?: boolean;
}

export class TopPlaylistRequestModel implements ITopPlaylistRequestModel {
    category?: string | undefined;
    order?: string | undefined;
    limit?: number;
    offset?: number;

    constructor(data?: ITopPlaylistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.order = _data["order"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): TopPlaylistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopPlaylistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["order"] = this.order;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface ITopPlaylistRequestModel {
    category?: string | undefined;
    order?: string | undefined;
    limit?: number;
    offset?: number;
}

export class TopicDetailRequestModel implements ITopicDetailRequestModel {
    actid?: string | undefined;

    constructor(data?: ITopicDetailRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actid = _data["actid"];
        }
    }

    static fromJS(data: any): TopicDetailRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopicDetailRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actid"] = this.actid;
        return data;
    }
}

export interface ITopicDetailRequestModel {
    actid?: string | undefined;
}

export class TopicSublistRequestModel implements ITopicSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;

    constructor(data?: ITopicSublistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): TopicSublistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopicSublistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["total"] = this.total;
        return data;
    }
}

export interface ITopicSublistRequestModel {
    limit?: number;
    offset?: number;
    total?: boolean;
}

export class ToplistArtistRequestModel implements IToplistArtistRequestModel {
    type?: number;
    limit?: number;
    offset?: number;

    constructor(data?: IToplistArtistRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): ToplistArtistRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ToplistArtistRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IToplistArtistRequestModel {
    type?: number;
    limit?: number;
    offset?: number;
}

export class TrackModel implements ITrackModel {
    id?: number;

    constructor(data?: ITrackModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrackModel {
        data = typeof data === 'object' ? data : {};
        let result = new TrackModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITrackModel {
    id?: number;
}

export class UgcArtistSearchRequestModel implements IUgcArtistSearchRequestModel {
    keyword?: string | undefined;
    limit?: number;

    constructor(data?: IUgcArtistSearchRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): UgcArtistSearchRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UgcArtistSearchRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IUgcArtistSearchRequestModel {
    keyword?: string | undefined;
    limit?: number;
}

export class UgcDetailRequestModel implements IUgcDetailRequestModel {
    auditStatus?: string | undefined;
    limit?: number;
    offset?: number;
    order?: string | undefined;
    sortBy?: string | undefined;
    type?: number;

    constructor(data?: IUgcDetailRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditStatus = _data["auditStatus"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.order = _data["order"];
            this.sortBy = _data["sortBy"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UgcDetailRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UgcDetailRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditStatus"] = this.auditStatus;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["order"] = this.order;
        data["sortBy"] = this.sortBy;
        data["type"] = this.type;
        return data;
    }
}

export interface IUgcDetailRequestModel {
    auditStatus?: string | undefined;
    limit?: number;
    offset?: number;
    order?: string | undefined;
    sortBy?: string | undefined;
    type?: number;
}

export class UserCommentHistoryRequestModel implements IUserCommentHistoryRequestModel {
    limit?: number;
    userId?: number;
    time?: number;
    composeReminder?: boolean;
    composeHotComment?: boolean;

    constructor(data?: IUserCommentHistoryRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.userId = _data["userId"];
            this.time = _data["time"];
            this.composeReminder = _data["composeReminder"];
            this.composeHotComment = _data["composeHotComment"];
        }
    }

    static fromJS(data: any): UserCommentHistoryRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserCommentHistoryRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["userId"] = this.userId;
        data["time"] = this.time;
        data["composeReminder"] = this.composeReminder;
        data["composeHotComment"] = this.composeHotComment;
        return data;
    }
}

export interface IUserCommentHistoryRequestModel {
    limit?: number;
    userId?: number;
    time?: number;
    composeReminder?: boolean;
    composeHotComment?: boolean;
}

export class UserEventRequestModel implements IUserEventRequestModel {
    userId?: number;
    limit?: number;
    lastTime?: number;
    total?: boolean;
    getCounts?: boolean;

    constructor(data?: IUserEventRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.limit = _data["limit"];
            this.lastTime = _data["lastTime"];
            this.total = _data["total"];
            this.getCounts = _data["getCounts"];
        }
    }

    static fromJS(data: any): UserEventRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserEventRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["limit"] = this.limit;
        data["lastTime"] = this.lastTime;
        data["total"] = this.total;
        data["getCounts"] = this.getCounts;
        return data;
    }
}

export interface IUserEventRequestModel {
    userId?: number;
    limit?: number;
    lastTime?: number;
    total?: boolean;
    getCounts?: boolean;
}

export class UserFollowMixedRequestModel implements IUserFollowMixedRequestModel {
    authority?: string | undefined;
    page?: PaginationModel;
    scene?: number;
    size?: number;
    sortType?: string | undefined;

    constructor(data?: IUserFollowMixedRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authority = _data["authority"];
            this.page = _data["page"] ? PaginationModel.fromJS(_data["page"]) : <any>undefined;
            this.scene = _data["scene"];
            this.size = _data["size"];
            this.sortType = _data["sortType"];
        }
    }

    static fromJS(data: any): UserFollowMixedRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserFollowMixedRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        data["scene"] = this.scene;
        data["size"] = this.size;
        data["sortType"] = this.sortType;
        return data;
    }
}

export interface IUserFollowMixedRequestModel {
    authority?: string | undefined;
    page?: PaginationModel;
    scene?: number;
    size?: number;
    sortType?: string | undefined;
}

export class UserFollowedsRequestModel implements IUserFollowedsRequestModel {
    userId?: string | undefined;
    time?: string | undefined;
    limit?: number;
    offset?: number;
    getCounts?: boolean;

    constructor(data?: IUserFollowedsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.time = _data["time"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            this.getCounts = _data["getCounts"];
        }
    }

    static fromJS(data: any): UserFollowedsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserFollowedsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["time"] = this.time;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        data["getCounts"] = this.getCounts;
        return data;
    }
}

export interface IUserFollowedsRequestModel {
    userId?: string | undefined;
    time?: string | undefined;
    limit?: number;
    offset?: number;
    getCounts?: boolean;
}

export class UserReplacePhoneRequestModel implements IUserReplacePhoneRequestModel {
    phone?: string | undefined;
    captcha?: string | undefined;
    oldCaptcha?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IUserReplacePhoneRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.captcha = _data["captcha"];
            this.oldCaptcha = _data["oldCaptcha"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): UserReplacePhoneRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserReplacePhoneRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["captcha"] = this.captcha;
        data["oldCaptcha"] = this.oldCaptcha;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

export interface IUserReplacePhoneRequestModel {
    phone?: string | undefined;
    captcha?: string | undefined;
    oldCaptcha?: string | undefined;
    countryCode?: string | undefined;
}

export class UserSocialStatusEditRequestModel implements IUserSocialStatusEditRequestModel {
    type?: string | undefined;
    iconUrl?: string | undefined;
    content?: string | undefined;
    actionUrl?: string | undefined;

    constructor(data?: IUserSocialStatusEditRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.content = _data["content"];
            this.actionUrl = _data["actionUrl"];
        }
    }

    static fromJS(data: any): UserSocialStatusEditRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserSocialStatusEditRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["content"] = this.content;
        data["actionUrl"] = this.actionUrl;
        return data;
    }
}

export interface IUserSocialStatusEditRequestModel {
    type?: string | undefined;
    iconUrl?: string | undefined;
    content?: string | undefined;
    actionUrl?: string | undefined;
}

export class UserUpdateRequestModel implements IUserUpdateRequestModel {
    birthday?: number;
    city?: number;
    gender?: number;
    nickname?: string | undefined;
    province?: number;
    signature?: string | undefined;

    constructor(data?: IUserUpdateRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthday = _data["birthday"];
            this.city = _data["city"];
            this.gender = _data["gender"];
            this.nickname = _data["nickname"];
            this.province = _data["province"];
            this.signature = _data["signature"];
        }
    }

    static fromJS(data: any): UserUpdateRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthday"] = this.birthday;
        data["city"] = this.city;
        data["gender"] = this.gender;
        data["nickname"] = this.nickname;
        data["province"] = this.province;
        data["signature"] = this.signature;
        return data;
    }
}

export interface IUserUpdateRequestModel {
    birthday?: number;
    city?: number;
    gender?: number;
    nickname?: string | undefined;
    province?: number;
    signature?: string | undefined;
}

export class VideoCategoryListRequestModel implements IVideoCategoryListRequestModel {
    offset?: number;
    limit?: number;
    total?: boolean;

    constructor(data?: IVideoCategoryListRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.limit = _data["limit"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): VideoCategoryListRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoCategoryListRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        data["total"] = this.total;
        return data;
    }
}

export interface IVideoCategoryListRequestModel {
    offset?: number;
    limit?: number;
    total?: boolean;
}

export class VideoGroupRequestModel implements IVideoGroupRequestModel {
    groupId?: number;
    offset?: number;
    needPreviewUrl?: boolean;
    total?: boolean;

    constructor(data?: IVideoGroupRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.offset = _data["offset"];
            this.needPreviewUrl = _data["needPreviewUrl"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): VideoGroupRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoGroupRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["offset"] = this.offset;
        data["needPreviewUrl"] = this.needPreviewUrl;
        data["total"] = this.total;
        return data;
    }
}

export interface IVideoGroupRequestModel {
    groupId?: number;
    offset?: number;
    needPreviewUrl?: boolean;
    total?: boolean;
}

export class VideoTimelineRecommendRequestModel implements IVideoTimelineRecommendRequestModel {
    offset?: number;
    filterLives?: string | undefined;
    withProgramInfo?: boolean;
    needUrl?: boolean;
    resolution?: string | undefined;

    constructor(data?: IVideoTimelineRecommendRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.filterLives = _data["filterLives"];
            this.withProgramInfo = _data["withProgramInfo"];
            this.needUrl = _data["needUrl"];
            this.resolution = _data["resolution"];
        }
    }

    static fromJS(data: any): VideoTimelineRecommendRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoTimelineRecommendRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["filterLives"] = this.filterLives;
        data["withProgramInfo"] = this.withProgramInfo;
        data["needUrl"] = this.needUrl;
        data["resolution"] = this.resolution;
        return data;
    }
}

export interface IVideoTimelineRecommendRequestModel {
    offset?: number;
    filterLives?: string | undefined;
    withProgramInfo?: boolean;
    needUrl?: boolean;
    resolution?: string | undefined;
}

export class VideoTimelineRequestModel implements IVideoTimelineRequestModel {
    offset?: number;
    needPreviewUrl?: boolean;

    constructor(data?: IVideoTimelineRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.needPreviewUrl = _data["needPreviewUrl"];
        }
    }

    static fromJS(data: any): VideoTimelineRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VideoTimelineRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["needPreviewUrl"] = this.needPreviewUrl;
        return data;
    }
}

export interface IVideoTimelineRequestModel {
    offset?: number;
    needPreviewUrl?: boolean;
}

export class VipGrowthPointDetailsRequestModel implements IVipGrowthPointDetailsRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IVipGrowthPointDetailsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): VipGrowthPointDetailsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VipGrowthPointDetailsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IVipGrowthPointDetailsRequestModel {
    limit?: number;
    offset?: number;
}

export class VipGrowthpointGetRequestModel implements IVipGrowthpointGetRequestModel {
    taskIds?: string | undefined;

    constructor(data?: IVipGrowthpointGetRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskIds = _data["taskIds"];
        }
    }

    static fromJS(data: any): VipGrowthpointGetRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VipGrowthpointGetRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskIds"] = this.taskIds;
        return data;
    }
}

export interface IVipGrowthpointGetRequestModel {
    taskIds?: string | undefined;
}

export class VipTimeMachineRequestModel implements IVipTimeMachineRequestModel {
    startTime?: number | undefined;
    endTime?: number | undefined;
    type?: number;
    limit?: number;

    constructor(data?: IVipTimeMachineRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.type = _data["type"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): VipTimeMachineRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new VipTimeMachineRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["type"] = this.type;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IVipTimeMachineRequestModel {
    startTime?: number | undefined;
    endTime?: number | undefined;
    type?: number;
    limit?: number;
}

export class YunbeiExpenseRequestModel implements IYunbeiExpenseRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IYunbeiExpenseRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): YunbeiExpenseRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiExpenseRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IYunbeiExpenseRequestModel {
    limit?: number;
    offset?: number;
}

export class YunbeiRcmdSongHistoryPage implements IYunbeiRcmdSongHistoryPage {
    size?: number;
    cursor?: string | undefined;

    constructor(data?: IYunbeiRcmdSongHistoryPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): YunbeiRcmdSongHistoryPage {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiRcmdSongHistoryPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface IYunbeiRcmdSongHistoryPage {
    size?: number;
    cursor?: string | undefined;
}

export class YunbeiRcmdSongHistoryRequestModel implements IYunbeiRcmdSongHistoryRequestModel {
    page?: YunbeiRcmdSongHistoryPage;

    constructor(data?: IYunbeiRcmdSongHistoryRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? YunbeiRcmdSongHistoryPage.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): YunbeiRcmdSongHistoryRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiRcmdSongHistoryRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IYunbeiRcmdSongHistoryRequestModel {
    page?: YunbeiRcmdSongHistoryPage;
}

export class YunbeiReceiptRequestModel implements IYunbeiReceiptRequestModel {
    limit?: number;
    offset?: number;

    constructor(data?: IYunbeiReceiptRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): YunbeiReceiptRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiReceiptRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IYunbeiReceiptRequestModel {
    limit?: number;
    offset?: number;
}

export class YunbeiRecommendedSongsRequestModel implements IYunbeiRecommendedSongsRequestModel {
    songId?: string | undefined;
    reason?: string | undefined;
    scene?: string | undefined;
    fromUserId?: number;
    yunbeiNum?: number;

    constructor(data?: IYunbeiRecommendedSongsRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.songId = _data["songId"];
            this.reason = _data["reason"];
            this.scene = _data["scene"];
            this.fromUserId = _data["fromUserId"];
            this.yunbeiNum = _data["yunbeiNum"];
        }
    }

    static fromJS(data: any): YunbeiRecommendedSongsRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiRecommendedSongsRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["songId"] = this.songId;
        data["reason"] = this.reason;
        data["scene"] = this.scene;
        data["fromUserId"] = this.fromUserId;
        data["yunbeiNum"] = this.yunbeiNum;
        return data;
    }
}

export interface IYunbeiRecommendedSongsRequestModel {
    songId?: string | undefined;
    reason?: string | undefined;
    scene?: string | undefined;
    fromUserId?: number;
    yunbeiNum?: number;
}

export class YunbeiTaskFinishRequestModel implements IYunbeiTaskFinishRequestModel {
    userTaskId?: string | undefined;
    depositCode?: string | undefined;

    constructor(data?: IYunbeiTaskFinishRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userTaskId = _data["userTaskId"];
            this.depositCode = _data["depositCode"];
        }
    }

    static fromJS(data: any): YunbeiTaskFinishRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new YunbeiTaskFinishRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userTaskId"] = this.userTaskId;
        data["depositCode"] = this.depositCode;
        return data;
    }
}

export interface IYunbeiTaskFinishRequestModel {
    userTaskId?: string | undefined;
    depositCode?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}